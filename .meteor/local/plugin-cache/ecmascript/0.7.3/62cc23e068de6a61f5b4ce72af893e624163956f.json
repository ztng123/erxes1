{"metadata":{"usedHelpers":["extends","interopRequireDefault"],"marked":[],"modules":{"imports":[{"source":"meteor/meteor","imported":["Meteor"],"specifiers":[{"kind":"named","imported":"Meteor","local":"Meteor"}]},{"source":"meteor/check","imported":["check"],"specifiers":[{"kind":"named","imported":"check","local":"check"}]},{"source":"meteor/underscore","imported":["_"],"specifiers":[{"kind":"named","imported":"_","local":"_"}]},{"source":"meteor/mdg:validated-method","imported":["ValidatedMethod"],"specifiers":[{"kind":"named","imported":"ValidatedMethod","local":"ValidatedMethod"}]},{"source":"strip","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"strip"}]},{"source":"/imports/api/utils","imported":["ErxesMixin"],"specifiers":[{"kind":"named","imported":"ErxesMixin","local":"ErxesMixin"}]},{"source":"/imports/api/server/utils","imported":["sendNotification","sendEmail"],"specifiers":[{"kind":"named","imported":"sendNotification","local":"sendNotification"},{"kind":"named","imported":"sendEmail","local":"sendEmail"}]},{"source":"/imports/api/integrations/constants","imported":["KIND_CHOICES"],"specifiers":[{"kind":"named","imported":"KIND_CHOICES","local":"KIND_CHOICES"}]},{"source":"/imports/api/integrations/social/server/twitter","imported":["tweetReply"],"specifiers":[{"kind":"named","imported":"tweetReply","local":"tweetReply"}]},{"source":"/imports/api/integrations/social/server/facebook","imported":["facebookReply"],"specifiers":[{"kind":"named","imported":"facebookReply","local":"facebookReply"}]},{"source":"/imports/api/conversations/messages","imported":["Messages","FormSchema"],"specifiers":[{"kind":"named","imported":"Messages","local":"Messages"},{"kind":"named","imported":"FormSchema","local":"FormSchema"}]},{"source":"/imports/api/conversations/conversations","imported":["Conversations","ConversationIdsSchema","AssignSchema","ChangeStatusSchema"],"specifiers":[{"kind":"named","imported":"Conversations","local":"Conversations"},{"kind":"named","imported":"ConversationIdsSchema","local":"ConversationIdsSchema"},{"kind":"named","imported":"AssignSchema","local":"AssignSchema"},{"kind":"named","imported":"ChangeStatusSchema","local":"ChangeStatusSchema"}]},{"source":"/imports/api/conversations/constants","imported":["CONVERSATION_STATUSES"],"specifiers":[{"kind":"named","imported":"CONVERSATION_STATUSES","local":"CONVERSATION_STATUSES"}]},{"source":"./apolloPubSubs","imported":["conversationsChanged","messageInserted"],"specifiers":[{"kind":"named","imported":"conversationsChanged","local":"conversationsChanged"},{"kind":"named","imported":"messageInserted","local":"messageInserted"}]}],"exports":{"exported":["addMessage","assign","unassign","changeStatus","star","unstar","toggleParticipate","markAsRead"],"specifiers":[{"kind":"local","local":"addMessage","exported":"addMessage"},{"kind":"local","local":"assign","exported":"assign"},{"kind":"local","local":"unassign","exported":"unassign"},{"kind":"local","local":"changeStatus","exported":"changeStatus"},{"kind":"local","local":"star","exported":"star"},{"kind":"local","local":"unstar","exported":"unstar"},{"kind":"local","local":"toggleParticipate","exported":"toggleParticipate"},{"kind":"local","local":"markAsRead","exported":"markAsRead"}]}}},"options":{"filename":"/imports/api/conversations/server/methods.js","filenameRelative":"/imports/api/conversations/server/methods.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/imports/api/conversations/server/methods.js.map","sourceFileName":"/imports/api/conversations/server/methods.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"methods"},"ignored":false,"code":"var _extends2 = require(\"babel-runtime/helpers/extends\");\n\nvar _extends3 = _interopRequireDefault(_extends2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nmodule.export({\n  addMessage: function () {\n    return addMessage;\n  },\n  assign: function () {\n    return assign;\n  },\n  unassign: function () {\n    return unassign;\n  },\n  changeStatus: function () {\n    return changeStatus;\n  },\n  star: function () {\n    return star;\n  },\n  unstar: function () {\n    return unstar;\n  },\n  toggleParticipate: function () {\n    return toggleParticipate;\n  },\n  markAsRead: function () {\n    return markAsRead;\n  }\n});\nvar Meteor = void 0;\nmodule.importSync(\"meteor/meteor\", {\n  Meteor: function (v) {\n    Meteor = v;\n  }\n}, 0);\nvar check = void 0;\nmodule.importSync(\"meteor/check\", {\n  check: function (v) {\n    check = v;\n  }\n}, 1);\n\nvar _ = void 0;\n\nmodule.importSync(\"meteor/underscore\", {\n  _: function (v) {\n    _ = v;\n  }\n}, 2);\nvar ValidatedMethod = void 0;\nmodule.importSync(\"meteor/mdg:validated-method\", {\n  ValidatedMethod: function (v) {\n    ValidatedMethod = v;\n  }\n}, 3);\nvar strip = void 0;\nmodule.importSync(\"strip\", {\n  \"default\": function (v) {\n    strip = v;\n  }\n}, 4);\nvar ErxesMixin = void 0;\nmodule.importSync(\"/imports/api/utils\", {\n  ErxesMixin: function (v) {\n    ErxesMixin = v;\n  }\n}, 5);\nvar sendNotification = void 0,\n    sendEmail = void 0;\nmodule.importSync(\"/imports/api/server/utils\", {\n  sendNotification: function (v) {\n    sendNotification = v;\n  },\n  sendEmail: function (v) {\n    sendEmail = v;\n  }\n}, 6);\nvar KIND_CHOICES = void 0;\nmodule.importSync(\"/imports/api/integrations/constants\", {\n  KIND_CHOICES: function (v) {\n    KIND_CHOICES = v;\n  }\n}, 7);\nvar tweetReply = void 0;\nmodule.importSync(\"/imports/api/integrations/social/server/twitter\", {\n  tweetReply: function (v) {\n    tweetReply = v;\n  }\n}, 8);\nvar facebookReply = void 0;\nmodule.importSync(\"/imports/api/integrations/social/server/facebook\", {\n  facebookReply: function (v) {\n    facebookReply = v;\n  }\n}, 9);\nvar Messages = void 0,\n    FormSchema = void 0;\nmodule.importSync(\"/imports/api/conversations/messages\", {\n  Messages: function (v) {\n    Messages = v;\n  },\n  FormSchema: function (v) {\n    FormSchema = v;\n  }\n}, 10);\nvar Conversations = void 0,\n    ConversationIdsSchema = void 0,\n    AssignSchema = void 0,\n    ChangeStatusSchema = void 0;\nmodule.importSync(\"/imports/api/conversations/conversations\", {\n  Conversations: function (v) {\n    Conversations = v;\n  },\n  ConversationIdsSchema: function (v) {\n    ConversationIdsSchema = v;\n  },\n  AssignSchema: function (v) {\n    AssignSchema = v;\n  },\n  ChangeStatusSchema: function (v) {\n    ChangeStatusSchema = v;\n  }\n}, 11);\nvar CONVERSATION_STATUSES = void 0;\nmodule.importSync(\"/imports/api/conversations/constants\", {\n  CONVERSATION_STATUSES: function (v) {\n    CONVERSATION_STATUSES = v;\n  }\n}, 12);\nvar conversationsChanged = void 0,\n    messageInserted = void 0;\nmodule.importSync(\"./apolloPubSubs\", {\n  conversationsChanged: function (v) {\n    conversationsChanged = v;\n  },\n  messageInserted: function (v) {\n    messageInserted = v;\n  }\n}, 13);\n\n/*\n * all possible users they can get notifications\n */var conversationNotifReceivers = function (conversation, currentUserId) {\n  var userIds = []; // assigned user can get notifications\n\n  if (conversation.assignedUserId) {\n    userIds.push(conversation.assignedUserId);\n  } // participated users can get notifications\n\n\n  if (conversation.participatedUserIds) {\n    userIds = _.union(userIds, conversation.participatedUserIds);\n  } // exclude current user\n\n\n  userIds = _.without(userIds, currentUserId);\n  return userIds;\n}; /*\n    * create new message from admin\n    */\n\nvar addMessage = new ValidatedMethod({\n  name: 'conversations.addMessage',\n  mixins: [ErxesMixin],\n  validate: FormSchema.validator(),\n  run: function (_doc) {\n    var doc = _doc;\n    var conversation = Conversations.findOne(doc.conversationId);\n\n    if (!conversation) {\n      throw new Meteor.Error('conversations.addMessage.conversationNotFound', 'Conversation not found');\n    }\n\n    var integration = conversation.integration(); // normalize content, attachments\n\n    var content = doc.content || '';\n    var attachments = doc.attachments || [];\n    doc.content = content;\n    doc.attachments = attachments; // if there is no attachments and no content then throw content required\n    // error\n\n    if (attachments.length === 0 && !strip(content)) {\n      throw new Meteor.Error('conversations.addMessage.contentRequired', 'Content is required');\n    } // setting conversation's content to last message\n\n\n    Conversations.update({\n      _id: doc.conversationId\n    }, {\n      $set: {\n        content: content\n      }\n    });\n    var title = 'You have a new message.'; // send notification\n\n    sendNotification({\n      createdUser: this.userId,\n      notifType: 'conversationAddMessage',\n      title: title,\n      content: content,\n      link: \"/inbox/details/\" + conversation._id,\n      receivers: conversationNotifReceivers(conversation, this.userId)\n    });\n    var userId = this.userId; // do not send internal message to third service integrations\n\n    if (doc.internal) {\n      return Messages.insert((0, _extends3.default)({}, doc, {\n        userId: userId\n      }));\n    } // send reply to twitter\n\n\n    if (integration.kind === KIND_CHOICES.TWITTER) {\n      return tweetReply(conversation, strip(content));\n    }\n\n    var messageId = Messages.insert((0, _extends3.default)({}, doc, {\n      userId: userId\n    })); // notify graphl subscription\n\n    messageInserted(messageId);\n    var customer = conversation.customer(); // if conversation's integration kind is form then send reply to\n    // customer's email\n\n    var kind = integration.kind;\n    var email = customer ? customer.email : '';\n\n    if (kind === KIND_CHOICES.FORM && email) {\n      sendEmail({\n        to: customer.email,\n        subject: 'Reply',\n        template: {\n          name: 'notification',\n          data: {\n            notification: {\n              title: 'reply',\n              content: content,\n              date: new Date()\n            }\n          }\n        }\n      });\n    } // send reply to facebook\n\n\n    if (integration.kind === KIND_CHOICES.FACEBOOK) {\n      // when facebook kind is feed, assign commentId in extraData\n      facebookReply(conversation, strip(content), messageId);\n    }\n\n    return messageId;\n  }\n});\n\nvar checkConversationsExistance = function (conversationIds) {\n  var selector = {\n    _id: {\n      $in: conversationIds\n    }\n  };\n  var conversations = Conversations.find(selector).fetch();\n\n  if (conversations.length !== conversationIds.length) {\n    throw new Meteor.Error('conversations.conversationNotFound', 'Conversation not found.');\n  }\n\n  return {\n    selector: selector,\n    conversations: conversations\n  };\n}; /*\n    * assign employee to conversation\n    */\n\nvar assign = new ValidatedMethod({\n  name: 'conversations.assign',\n  mixins: [ErxesMixin],\n  validate: AssignSchema.validator(),\n  run: function (_ref) {\n    var _this = this;\n\n    var conversationIds = _ref.conversationIds,\n        assignedUserId = _ref.assignedUserId;\n\n    // check conversations existance\n    var _checkConversationsEx = checkConversationsExistance(conversationIds),\n        selector = _checkConversationsEx.selector;\n\n    if (!Meteor.users.findOne(assignedUserId)) {\n      throw new Meteor.Error('conversations.assign.userNotFound', 'User not found.');\n    }\n\n    Conversations.update({\n      _id: {\n        $in: conversationIds\n      }\n    }, {\n      $set: {\n        assignedUserId: assignedUserId\n      }\n    }, {\n      multi: true\n    }); // notify graphl subscription\n\n    conversationsChanged(conversationIds, 'statusChanged');\n    var updatedConversations = Conversations.find(selector).fetch(); // send notification\n\n    _.each(updatedConversations, function (conversation) {\n      var content = 'Assigned user has changed';\n      sendNotification({\n        createdUser: _this.userId,\n        notifType: 'conversationAssigneeChange',\n        title: content,\n        content: content,\n        link: \"/inbox/details/\" + conversation._id,\n        receivers: conversationNotifReceivers(conversation, _this.userId)\n      });\n    });\n  }\n});\nvar unassign = new ValidatedMethod({\n  name: 'conversations.unassign',\n  mixins: [ErxesMixin],\n  validate: ConversationIdsSchema.validator(),\n  run: function (_ref2) {\n    var conversationIds = _ref2.conversationIds;\n    // check conversations existance\n    checkConversationsExistance(conversationIds);\n    Conversations.update({\n      _id: {\n        $in: conversationIds\n      }\n    }, {\n      $unset: {\n        assignedUserId: 1\n      }\n    }, {\n      multi: true\n    }); // notify graphl subscription\n\n    conversationsChanged(conversationIds, 'statusChanged');\n  }\n});\nvar changeStatus = new ValidatedMethod({\n  name: 'conversations.changeStatus',\n  mixins: [ErxesMixin],\n  validate: ChangeStatusSchema.validator(),\n  run: function (_ref3) {\n    var _this2 = this;\n\n    var conversationIds = _ref3.conversationIds,\n        status = _ref3.status;\n\n    // check conversations existance\n    var _checkConversationsEx2 = checkConversationsExistance(conversationIds),\n        conversations = _checkConversationsEx2.conversations;\n\n    Conversations.update({\n      _id: {\n        $in: conversationIds\n      }\n    }, {\n      $set: {\n        status: status\n      }\n    }, {\n      multi: true\n    }); // notify graphl subscription\n\n    conversationsChanged(conversationIds, 'statusChanged'); // send notification\n\n    _.each(conversations, function (conversation) {\n      // if associated integration's notify customer config is setted as true\n      // send email to customer, when conversation close\n      if (status === CONVERSATION_STATUSES.CLOSED) {\n        var customer = conversation.customer();\n        var integration = conversation.integration();\n        var messengerData = integration.messengerData || {};\n        var notifyCustomer = messengerData.notifyCustomer || false;\n\n        if (notifyCustomer && customer.email) {\n          // send email to customer\n          sendEmail({\n            to: customer.email,\n            subject: 'Conversation detail',\n            template: {\n              name: 'conversationDetail',\n              data: {\n                conversationDetail: {\n                  title: 'Conversation detail',\n                  messages: Messages.find({\n                    conversationId: conversation._id\n                  }).fetch(),\n                  date: new Date()\n                }\n              }\n            }\n          });\n        }\n      }\n\n      var content = 'Conversation status has changed.';\n      sendNotification({\n        createdUser: _this2.userId,\n        notifType: 'conversationStateChange',\n        title: content,\n        content: content,\n        link: \"/inbox/details/\" + conversation._id,\n        receivers: conversationNotifReceivers(conversation, _this2.userId)\n      });\n    });\n  }\n});\nvar star = new ValidatedMethod({\n  name: 'conversations.star',\n  mixins: [ErxesMixin],\n  validate: ConversationIdsSchema.validator(),\n  run: function (_ref4) {\n    var conversationIds = _ref4.conversationIds;\n    // check conversations existance\n    checkConversationsExistance(conversationIds);\n    Meteor.users.update(this.userId, {\n      $addToSet: {\n        'details.starredConversationIds': {\n          $each: conversationIds\n        }\n      }\n    });\n  }\n});\nvar unstar = new ValidatedMethod({\n  name: 'conversations.unstar',\n  mixins: [ErxesMixin],\n  validate: ConversationIdsSchema.validator(),\n  run: function (_ref5) {\n    var conversationIds = _ref5.conversationIds;\n    // check conversations existance\n    checkConversationsExistance(conversationIds);\n    Meteor.users.update(this.userId, {\n      $pull: {\n        'details.starredConversationIds': {\n          $in: conversationIds\n        }\n      }\n    });\n  }\n});\nvar toggleParticipate = new ValidatedMethod({\n  name: 'conversations.toggleParticipate',\n  mixins: [ErxesMixin],\n  validate: ConversationIdsSchema.validator(),\n  run: function (_ref6) {\n    var conversationIds = _ref6.conversationIds;\n\n    // check conversations existance\n    var _checkConversationsEx3 = checkConversationsExistance(conversationIds),\n        selector = _checkConversationsEx3.selector;\n\n    var extendSelector = (0, _extends3.default)({}, selector, {\n      participatedUserIds: {\n        $in: [this.userId]\n      }\n    }); // not previously added\n\n    if (Conversations.find(extendSelector).count() === 0) {\n      Conversations.update(selector, {\n        $addToSet: {\n          participatedUserIds: this.userId\n        }\n      }, {\n        multi: true\n      });\n    } else {\n      // remove\n      Conversations.update(selector, {\n        $pull: {\n          participatedUserIds: {\n            $in: [this.userId]\n          }\n        }\n      }, {\n        multi: true\n      });\n    } // notify graphl subscription\n\n\n    conversationsChanged(conversationIds, 'participatedStateChanged');\n  }\n});\nvar markAsRead = new ValidatedMethod({\n  name: 'conversations.markAsRead',\n  mixins: [ErxesMixin],\n  validate: function (_ref7) {\n    var conversationId = _ref7.conversationId;\n    check(conversationId, String);\n  },\n  run: function (_ref8) {\n    var conversationId = _ref8.conversationId;\n    var conversation = Conversations.findOne({\n      _id: conversationId\n    });\n\n    if (conversation) {\n      var readUserIds = conversation.readUserIds; // if current user is first one\n\n      if (!readUserIds) {\n        return Conversations.update({\n          _id: conversationId\n        }, {\n          $set: {\n            readUserIds: [this.userId]\n          }\n        });\n      } // if current user is not in read users list then add it\n\n\n      if (!readUserIds.includes(this.userId)) {\n        return Conversations.update({\n          _id: conversationId\n        }, {\n          $push: {\n            readUserIds: this.userId\n          }\n        });\n      }\n    }\n\n    return 'not affected';\n  }\n});","map":{"version":3,"sources":["/imports/api/conversations/server/methods.js"],"names":["module","export","addMessage","assign","unassign","changeStatus","star","unstar","toggleParticipate","markAsRead","Meteor","importSync","v","check","_","ValidatedMethod","strip","ErxesMixin","sendNotification","sendEmail","KIND_CHOICES","tweetReply","facebookReply","Messages","FormSchema","Conversations","ConversationIdsSchema","AssignSchema","ChangeStatusSchema","CONVERSATION_STATUSES","conversationsChanged","messageInserted","conversationNotifReceivers","conversation","currentUserId","userIds","assignedUserId","push","participatedUserIds","union","without","name","mixins","validate","validator","run","_doc","doc","findOne","conversationId","Error","integration","content","attachments","length","update","_id","$set","title","createdUser","userId","notifType","link","receivers","internal","insert","kind","TWITTER","messageId","customer","email","FORM","to","subject","template","data","notification","date","Date","FACEBOOK","checkConversationsExistance","selector","$in","conversationIds","conversations","find","fetch","users","multi","updatedConversations","each","$unset","status","CLOSED","messengerData","notifyCustomer","conversationDetail","messages","$addToSet","$each","$pull","extendSelector","count","String","readUserIds","includes","$push"],"mappings":"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","file":"/imports/api/conversations/server/methods.js.map","sourcesContent":["import { Meteor } from 'meteor/meteor';\nimport { check } from 'meteor/check';\nimport { _ } from 'meteor/underscore';\nimport { ValidatedMethod } from 'meteor/mdg:validated-method';\nimport strip from 'strip';\n\nimport { ErxesMixin } from '/imports/api/utils';\nimport { sendNotification, sendEmail } from '/imports/api/server/utils';\nimport { KIND_CHOICES } from '/imports/api/integrations/constants';\nimport { tweetReply } from '/imports/api/integrations/social/server/twitter';\nimport { facebookReply } from '/imports/api/integrations/social/server/facebook';\nimport { Messages, FormSchema } from '/imports/api/conversations/messages';\nimport {\n  Conversations,\n  ConversationIdsSchema,\n  AssignSchema,\n  ChangeStatusSchema,\n} from '/imports/api/conversations/conversations';\nimport { CONVERSATION_STATUSES } from '/imports/api/conversations/constants';\nimport { conversationsChanged, messageInserted } from './apolloPubSubs';\n\n/*\n * all possible users they can get notifications\n */\nconst conversationNotifReceivers = (conversation, currentUserId) => {\n  let userIds = [];\n\n  // assigned user can get notifications\n  if (conversation.assignedUserId) {\n    userIds.push(conversation.assignedUserId);\n  }\n\n  // participated users can get notifications\n  if (conversation.participatedUserIds) {\n    userIds = _.union(userIds, conversation.participatedUserIds);\n  }\n\n  // exclude current user\n  userIds = _.without(userIds, currentUserId);\n\n  return userIds;\n};\n\n/*\n * create new message from admin\n */\nexport const addMessage = new ValidatedMethod({\n  name: 'conversations.addMessage',\n  mixins: [ErxesMixin],\n  validate: FormSchema.validator(),\n\n  run(_doc) {\n    const doc = _doc;\n    const conversation = Conversations.findOne(doc.conversationId);\n\n    if (!conversation) {\n      throw new Meteor.Error(\n        'conversations.addMessage.conversationNotFound',\n        'Conversation not found',\n      );\n    }\n\n    const integration = conversation.integration();\n\n    // normalize content, attachments\n    const content = doc.content || '';\n    const attachments = doc.attachments || [];\n\n    doc.content = content;\n    doc.attachments = attachments;\n\n    // if there is no attachments and no content then throw content required\n    // error\n    if (attachments.length === 0 && !strip(content)) {\n      throw new Meteor.Error('conversations.addMessage.contentRequired', 'Content is required');\n    }\n\n    // setting conversation's content to last message\n    Conversations.update({ _id: doc.conversationId }, { $set: { content } });\n\n    const title = 'You have a new message.';\n\n    // send notification\n    sendNotification({\n      createdUser: this.userId,\n      notifType: 'conversationAddMessage',\n      title,\n      content,\n      link: `/inbox/details/${conversation._id}`,\n      receivers: conversationNotifReceivers(conversation, this.userId),\n    });\n\n    const userId = this.userId;\n\n    // do not send internal message to third service integrations\n    if (doc.internal) {\n      return Messages.insert({ ...doc, userId });\n    }\n\n    // send reply to twitter\n    if (integration.kind === KIND_CHOICES.TWITTER) {\n      return tweetReply(conversation, strip(content));\n    }\n\n    const messageId = Messages.insert({ ...doc, userId });\n\n    // notify graphl subscription\n    messageInserted(messageId);\n\n    const customer = conversation.customer();\n\n    // if conversation's integration kind is form then send reply to\n    // customer's email\n    const kind = integration.kind;\n    const email = customer ? customer.email : '';\n\n    if (kind === KIND_CHOICES.FORM && email) {\n      sendEmail({\n        to: customer.email,\n        subject: 'Reply',\n        template: {\n          name: 'notification',\n          data: {\n            notification: {\n              title: 'reply',\n              content,\n              date: new Date(),\n            },\n          },\n        },\n      });\n    }\n\n    // send reply to facebook\n    if (integration.kind === KIND_CHOICES.FACEBOOK) {\n      // when facebook kind is feed, assign commentId in extraData\n      facebookReply(conversation, strip(content), messageId);\n    }\n\n    return messageId;\n  },\n});\n\nconst checkConversationsExistance = conversationIds => {\n  const selector = { _id: { $in: conversationIds } };\n  const conversations = Conversations.find(selector).fetch();\n\n  if (conversations.length !== conversationIds.length) {\n    throw new Meteor.Error('conversations.conversationNotFound', 'Conversation not found.');\n  }\n\n  return { selector, conversations };\n};\n\n/*\n * assign employee to conversation\n */\nexport const assign = new ValidatedMethod({\n  name: 'conversations.assign',\n  mixins: [ErxesMixin],\n  validate: AssignSchema.validator(),\n\n  run({ conversationIds, assignedUserId }) {\n    // check conversations existance\n    const { selector } = checkConversationsExistance(conversationIds);\n\n    if (!Meteor.users.findOne(assignedUserId)) {\n      throw new Meteor.Error('conversations.assign.userNotFound', 'User not found.');\n    }\n\n    Conversations.update(\n      { _id: { $in: conversationIds } },\n      { $set: { assignedUserId } },\n      { multi: true },\n    );\n\n    // notify graphl subscription\n    conversationsChanged(conversationIds, 'statusChanged');\n\n    const updatedConversations = Conversations.find(selector).fetch();\n\n    // send notification\n    _.each(updatedConversations, conversation => {\n      const content = 'Assigned user has changed';\n\n      sendNotification({\n        createdUser: this.userId,\n        notifType: 'conversationAssigneeChange',\n        title: content,\n        content,\n        link: `/inbox/details/${conversation._id}`,\n        receivers: conversationNotifReceivers(conversation, this.userId),\n      });\n    });\n  },\n});\n\n/*\n * unassign employee from conversation\n */\nexport const unassign = new ValidatedMethod({\n  name: 'conversations.unassign',\n  mixins: [ErxesMixin],\n  validate: ConversationIdsSchema.validator(),\n\n  run({ conversationIds }) {\n    // check conversations existance\n    checkConversationsExistance(conversationIds);\n\n    Conversations.update(\n      { _id: { $in: conversationIds } },\n      { $unset: { assignedUserId: 1 } },\n      { multi: true },\n    );\n\n    // notify graphl subscription\n    conversationsChanged(conversationIds, 'statusChanged');\n  },\n});\n\n/*\n * change conversation status. closed, open etc...\n */\nexport const changeStatus = new ValidatedMethod({\n  name: 'conversations.changeStatus',\n  mixins: [ErxesMixin],\n  validate: ChangeStatusSchema.validator(),\n\n  run({ conversationIds, status }) {\n    // check conversations existance\n    const { conversations } = checkConversationsExistance(conversationIds);\n\n    Conversations.update({ _id: { $in: conversationIds } }, { $set: { status } }, { multi: true });\n\n    // notify graphl subscription\n    conversationsChanged(conversationIds, 'statusChanged');\n\n    // send notification\n    _.each(conversations, conversation => {\n      // if associated integration's notify customer config is setted as true\n      // send email to customer, when conversation close\n      if (status === CONVERSATION_STATUSES.CLOSED) {\n        const customer = conversation.customer();\n        const integration = conversation.integration();\n        const messengerData = integration.messengerData || {};\n        const notifyCustomer = messengerData.notifyCustomer || false;\n\n        if (notifyCustomer && customer.email) {\n          // send email to customer\n          sendEmail({\n            to: customer.email,\n            subject: 'Conversation detail',\n            template: {\n              name: 'conversationDetail',\n              data: {\n                conversationDetail: {\n                  title: 'Conversation detail',\n                  messages: Messages.find({ conversationId: conversation._id }).fetch(),\n                  date: new Date(),\n                },\n              },\n            },\n          });\n        }\n      }\n\n      const content = 'Conversation status has changed.';\n\n      sendNotification({\n        createdUser: this.userId,\n        notifType: 'conversationStateChange',\n        title: content,\n        content,\n        link: `/inbox/details/${conversation._id}`,\n        receivers: conversationNotifReceivers(conversation, this.userId),\n      });\n    });\n  },\n});\n\n/*\n * add given conversation to current user's starred list\n */\nexport const star = new ValidatedMethod({\n  name: 'conversations.star',\n  mixins: [ErxesMixin],\n  validate: ConversationIdsSchema.validator(),\n\n  run({ conversationIds }) {\n    // check conversations existance\n    checkConversationsExistance(conversationIds);\n\n    Meteor.users.update(this.userId, {\n      $addToSet: {\n        'details.starredConversationIds': { $each: conversationIds },\n      },\n    });\n  },\n});\n\n/*\n * remove given conversation from current user's starred list\n */\nexport const unstar = new ValidatedMethod({\n  name: 'conversations.unstar',\n  mixins: [ErxesMixin],\n  validate: ConversationIdsSchema.validator(),\n\n  run({ conversationIds }) {\n    // check conversations existance\n    checkConversationsExistance(conversationIds);\n\n    Meteor.users.update(this.userId, {\n      $pull: { 'details.starredConversationIds': { $in: conversationIds } },\n    });\n  },\n});\n\n/*\n * add or remove user from given conversations's participated list\n */\nexport const toggleParticipate = new ValidatedMethod({\n  name: 'conversations.toggleParticipate',\n  mixins: [ErxesMixin],\n  validate: ConversationIdsSchema.validator(),\n\n  run({ conversationIds }) {\n    // check conversations existance\n    const { selector } = checkConversationsExistance(conversationIds);\n\n    const extendSelector = {\n      ...selector,\n      participatedUserIds: { $in: [this.userId] },\n    };\n\n    // not previously added\n    if (Conversations.find(extendSelector).count() === 0) {\n      Conversations.update(\n        selector,\n        { $addToSet: { participatedUserIds: this.userId } },\n        { multi: true },\n      );\n    } else {\n      // remove\n      Conversations.update(\n        selector,\n        { $pull: { participatedUserIds: { $in: [this.userId] } } },\n        { multi: true },\n      );\n    }\n\n    // notify graphl subscription\n    conversationsChanged(conversationIds, 'participatedStateChanged');\n  },\n});\n\n/*\n * mark given conversation as read for current user\n */\nexport const markAsRead = new ValidatedMethod({\n  name: 'conversations.markAsRead',\n  mixins: [ErxesMixin],\n\n  validate({ conversationId }) {\n    check(conversationId, String);\n  },\n\n  run({ conversationId }) {\n    const conversation = Conversations.findOne({ _id: conversationId });\n\n    if (conversation) {\n      const readUserIds = conversation.readUserIds;\n\n      // if current user is first one\n      if (!readUserIds) {\n        return Conversations.update(\n          { _id: conversationId },\n          { $set: { readUserIds: [this.userId] } },\n        );\n      }\n\n      // if current user is not in read users list then add it\n      if (!readUserIds.includes(this.userId)) {\n        return Conversations.update(\n          { _id: conversationId },\n          { $push: { readUserIds: this.userId } },\n        );\n      }\n    }\n\n    return 'not affected';\n  },\n});\n"]},"hash":"62cc23e068de6a61f5b4ce72af893e624163956f"}
