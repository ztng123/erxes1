{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[{"source":"moment","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"moment"}]}],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/imports/api/customers/queryBuilder.js","filenameRelative":"/imports/api/customers/queryBuilder.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/imports/api/customers/queryBuilder.js.map","sourceFileName":"/imports/api/customers/queryBuilder.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"queryBuilder"},"ignored":false,"code":"var moment = void 0;\nmodule.importSync(\"moment\", {\n  \"default\": function (v) {\n    moment = v;\n  }\n}, 0);\nmodule.export(\"default\", exports.default = {\n  segments: function (segment, headSegment) {\n    var _childQuery;\n\n    var query = {\n      $and: []\n    };\n    var childQuery = (_childQuery = {}, _childQuery[segment.connector === 'any' ? '$or' : '$and'] = segment.conditions.map(function (condition) {\n      var _ref;\n\n      return _ref = {}, _ref[condition.field] = convertConditionToQuery(condition), _ref;\n    }), _childQuery);\n\n    if (segment.conditions.length) {\n      query.$and.push(childQuery);\n    } // Fetching parent segment\n\n\n    var embeddedParentSegment = typeof segment.getParentSegment === 'function' ? segment.getParentSegment() : null;\n    var parentSegment = headSegment || embeddedParentSegment;\n\n    if (parentSegment) {\n      var _parentQuery;\n\n      var parentQuery = (_parentQuery = {}, _parentQuery[parentSegment.connector === 'any' ? '$or' : '$and'] = parentSegment.conditions.map(function (condition) {\n        var _ref2;\n\n        return _ref2 = {}, _ref2[condition.field] = convertConditionToQuery(condition), _ref2;\n      }), _parentQuery);\n\n      if (parentSegment.conditions.length) {\n        query.$and.push(parentQuery);\n      }\n    }\n\n    return query.$and.length ? query : {};\n  }\n});\n\nfunction convertConditionToQuery(condition) {\n  var operator = condition.operator,\n      type = condition.type,\n      dateUnit = condition.dateUnit,\n      value = condition.value;\n  var transformedValue = void 0;\n\n  switch (type) {\n    case 'string':\n      transformedValue = value && value.toLowerCase();\n      break;\n\n    case 'number':\n    case 'date':\n      transformedValue = parseInt(value, 10);\n      break;\n\n    default:\n      transformedValue = value;\n      break;\n  }\n\n  switch (operator) {\n    case 'e':\n    case 'et':\n    default:\n      return transformedValue;\n\n    case 'dne':\n      return {\n        $ne: transformedValue\n      };\n\n    case 'c':\n      return {\n        $regex: new RegExp(\".*\" + escapeRegExp(transformedValue) + \".*\", 'i')\n      };\n\n    case 'dnc':\n      return {\n        $regex: new RegExp(\"^((?!\" + escapeRegExp(transformedValue) + \").)*$\", 'i')\n      };\n\n    case 'igt':\n      return {\n        $gt: transformedValue\n      };\n\n    case 'ilt':\n      return {\n        $lt: transformedValue\n      };\n\n    case 'it':\n      return true;\n\n    case 'if':\n      return false;\n\n    case 'wlt':\n      return {\n        $gte: moment().subtract(transformedValue, dateUnit).toDate(),\n        $lte: new Date()\n      };\n\n    case 'wmt':\n      return {\n        $lte: moment().subtract(transformedValue, dateUnit).toDate()\n      };\n\n    case 'wow':\n      return {\n        $lte: moment().add(transformedValue, dateUnit).toDate(),\n        $gte: new Date()\n      };\n\n    case 'woa':\n      return {\n        $gte: moment().add(transformedValue, dateUnit).toDate()\n      };\n\n    case 'is':\n      return {\n        $exists: true\n      };\n\n    case 'ins':\n      return {\n        $exists: false\n      };\n  }\n}\n\nfunction escapeRegExp(string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // $& means the whole matched string\n}","map":{"version":3,"sources":["/imports/api/customers/queryBuilder.js"],"names":["moment","module","importSync","v","export","exports","default","segments","segment","headSegment","query","$and","childQuery","connector","conditions","map","condition","field","convertConditionToQuery","length","push","embeddedParentSegment","getParentSegment","parentSegment","parentQuery","operator","type","dateUnit","value","transformedValue","toLowerCase","parseInt","$ne","$regex","RegExp","escapeRegExp","$gt","$lt","$gte","subtract","toDate","$lte","Date","add","$exists","string","replace"],"mappings":"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","file":"/imports/api/customers/queryBuilder.js.map","sourcesContent":["import moment from 'moment';\n\nexport default {\n  segments(segment, headSegment) {\n    const query = { $and: [] };\n\n    const childQuery = {\n      [segment.connector === 'any' ? '$or' : '$and']: segment.conditions.map(condition => ({\n        [condition.field]: convertConditionToQuery(condition),\n      })),\n    };\n    if (segment.conditions.length) {\n      query.$and.push(childQuery);\n    }\n\n    // Fetching parent segment\n    const embeddedParentSegment = typeof segment.getParentSegment === 'function'\n      ? segment.getParentSegment()\n      : null;\n    const parentSegment = headSegment || embeddedParentSegment;\n\n    if (parentSegment) {\n      const parentQuery = {\n        [parentSegment.connector === 'any'\n          ? '$or'\n          : '$and']: parentSegment.conditions.map(condition => ({\n          [condition.field]: convertConditionToQuery(condition),\n        })),\n      };\n      if (parentSegment.conditions.length) {\n        query.$and.push(parentQuery);\n      }\n    }\n\n    return query.$and.length ? query : {};\n  },\n};\n\nfunction convertConditionToQuery(condition) {\n  const { operator, type, dateUnit, value } = condition;\n  let transformedValue;\n\n  switch (type) {\n    case 'string':\n      transformedValue = value && value.toLowerCase();\n      break;\n    case 'number':\n    case 'date':\n      transformedValue = parseInt(value, 10);\n      break;\n    default:\n      transformedValue = value;\n      break;\n  }\n\n  switch (operator) {\n    case 'e':\n    case 'et':\n    default:\n      return transformedValue;\n    case 'dne':\n      return { $ne: transformedValue };\n    case 'c':\n      return { $regex: new RegExp(`.*${escapeRegExp(transformedValue)}.*`, 'i') };\n    case 'dnc':\n      return { $regex: new RegExp(`^((?!${escapeRegExp(transformedValue)}).)*$`, 'i') };\n    case 'igt':\n      return { $gt: transformedValue };\n    case 'ilt':\n      return { $lt: transformedValue };\n    case 'it':\n      return true;\n    case 'if':\n      return false;\n    case 'wlt':\n      return {\n        $gte: moment().subtract(transformedValue, dateUnit).toDate(),\n        $lte: new Date(),\n      };\n    case 'wmt':\n      return {\n        $lte: moment().subtract(transformedValue, dateUnit).toDate(),\n      };\n    case 'wow':\n      return {\n        $lte: moment().add(transformedValue, dateUnit).toDate(),\n        $gte: new Date(),\n      };\n    case 'woa':\n      return {\n        $gte: moment().add(transformedValue, dateUnit).toDate(),\n      };\n    case 'is':\n      return { $exists: true };\n    case 'ins':\n      return { $exists: false };\n  }\n}\n\nfunction escapeRegExp(string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // $& means the whole matched string\n}\n"]},"hash":"63097925f2f823c98c0cccfc9b3514a4118f8f0f"}
