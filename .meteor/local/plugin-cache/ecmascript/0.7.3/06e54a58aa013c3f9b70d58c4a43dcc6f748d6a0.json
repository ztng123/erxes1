{"metadata":{"usedHelpers":["toConsumableArray","classCallCheck","extends","interopRequireDefault"],"marked":[],"modules":{"imports":[{"source":"fbgraph","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"graph"}]},{"source":"meteor/meteorhacks:picker","imported":["Picker"],"specifiers":[{"kind":"named","imported":"Picker","local":"Picker"}]},{"source":"meteor/meteor","imported":["Meteor"],"specifiers":[{"kind":"named","imported":"Meteor","local":"Meteor"}]},{"source":"/imports/api/server/utils","imported":["apolloNotifyNewMessage"],"specifiers":[{"kind":"named","imported":"apolloNotifyNewMessage","local":"apolloNotifyNewMessage"}]},{"source":"/imports/api/conversations/conversations","imported":["Conversations"],"specifiers":[{"kind":"named","imported":"Conversations","local":"Conversations"}]},{"source":"/imports/api/conversations/messages","imported":["Messages"],"specifiers":[{"kind":"named","imported":"Messages","local":"Messages"}]},{"source":"/imports/api/customers/customers","imported":["Customers"],"specifiers":[{"kind":"named","imported":"Customers","local":"Customers"}]},{"source":"/imports/api/integrations/integrations","imported":["Integrations"],"specifiers":[{"kind":"named","imported":"Integrations","local":"Integrations"}]},{"source":"/imports/api/integrations/constants","imported":["KIND_CHOICES"],"specifiers":[{"kind":"named","imported":"KIND_CHOICES","local":"KIND_CHOICES"}]},{"source":"/imports/api/conversations/constants","imported":["CONVERSATION_STATUSES","FACEBOOK_DATA_KINDS"],"specifiers":[{"kind":"named","imported":"CONVERSATION_STATUSES","local":"CONVERSATION_STATUSES"},{"kind":"named","imported":"FACEBOOK_DATA_KINDS","local":"FACEBOOK_DATA_KINDS"}]}],"exports":{"exported":["graphRequest","getPageList","SaveWebhookResponse","receiveWebhookResponse","facebookReply"],"specifiers":[{"kind":"local","local":"graphRequest","exported":"graphRequest"},{"kind":"local","local":"getPageList","exported":"getPageList"},{"kind":"local","local":"SaveWebhookResponse","exported":"SaveWebhookResponse"},{"kind":"local","local":"receiveWebhookResponse","exported":"receiveWebhookResponse"},{"kind":"local","local":"facebookReply","exported":"facebookReply"}]}}},"options":{"filename":"/imports/api/integrations/social/server/facebook.js","filenameRelative":"/imports/api/integrations/social/server/facebook.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/imports/api/integrations/social/server/facebook.js.map","sourceFileName":"/imports/api/integrations/social/server/facebook.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"facebook"},"ignored":false,"code":"var _extends2 = require(\"babel-runtime/helpers/extends\");\n\nvar _extends3 = _interopRequireDefault(_extends2);\n\nvar _classCallCheck2 = require(\"babel-runtime/helpers/classCallCheck\");\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _toConsumableArray2 = require(\"babel-runtime/helpers/toConsumableArray\");\n\nvar _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nmodule.export({\n  graphRequest: function () {\n    return graphRequest;\n  },\n  getPageList: function () {\n    return getPageList;\n  },\n  SaveWebhookResponse: function () {\n    return SaveWebhookResponse;\n  },\n  receiveWebhookResponse: function () {\n    return receiveWebhookResponse;\n  },\n  facebookReply: function () {\n    return facebookReply;\n  }\n});\nvar graph = void 0;\nmodule.importSync(\"fbgraph\", {\n  \"default\": function (v) {\n    graph = v;\n  }\n}, 0);\nvar Picker = void 0;\nmodule.importSync(\"meteor/meteorhacks:picker\", {\n  Picker: function (v) {\n    Picker = v;\n  }\n}, 1);\nvar Meteor = void 0;\nmodule.importSync(\"meteor/meteor\", {\n  Meteor: function (v) {\n    Meteor = v;\n  }\n}, 2);\nvar apolloNotifyNewMessage = void 0;\nmodule.importSync(\"/imports/api/server/utils\", {\n  apolloNotifyNewMessage: function (v) {\n    apolloNotifyNewMessage = v;\n  }\n}, 3);\nvar Conversations = void 0;\nmodule.importSync(\"/imports/api/conversations/conversations\", {\n  Conversations: function (v) {\n    Conversations = v;\n  }\n}, 4);\nvar Messages = void 0;\nmodule.importSync(\"/imports/api/conversations/messages\", {\n  Messages: function (v) {\n    Messages = v;\n  }\n}, 5);\nvar Customers = void 0;\nmodule.importSync(\"/imports/api/customers/customers\", {\n  Customers: function (v) {\n    Customers = v;\n  }\n}, 6);\nvar Integrations = void 0;\nmodule.importSync(\"/imports/api/integrations/integrations\", {\n  Integrations: function (v) {\n    Integrations = v;\n  }\n}, 7);\nvar KIND_CHOICES = void 0;\nmodule.importSync(\"/imports/api/integrations/constants\", {\n  KIND_CHOICES: function (v) {\n    KIND_CHOICES = v;\n  }\n}, 8);\nvar CONVERSATION_STATUSES = void 0,\n    FACEBOOK_DATA_KINDS = void 0;\nmodule.importSync(\"/imports/api/conversations/constants\", {\n  CONVERSATION_STATUSES: function (v) {\n    CONVERSATION_STATUSES = v;\n  },\n  FACEBOOK_DATA_KINDS: function (v) {\n    FACEBOOK_DATA_KINDS = v;\n  }\n}, 9);\nvar graphRequest = {\n  base: function (method, path, accessToken) {\n    // set access token\n    graph.setAccessToken(accessToken);\n    var wrappedGraph = Meteor.wrapAsync(graph[method], graph);\n\n    try {\n      for (var _len = arguments.length, otherParams = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n        otherParams[_key - 3] = arguments[_key];\n      }\n\n      return wrappedGraph.apply(undefined, [path].concat((0, _toConsumableArray3.default)(otherParams))); // catch session expired or some other error\n    } catch (e) {\n      console.log(e.message); // eslint-disable-line no-console\n\n      return e.message;\n    }\n  },\n  get: function () {\n    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    return this.base.apply(this, ['get'].concat((0, _toConsumableArray3.default)(args)));\n  },\n  post: function () {\n    for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n\n    return this.base.apply(this, ['post'].concat((0, _toConsumableArray3.default)(args)));\n  }\n};\n\nvar getPageList = function (accessToken) {\n  var response = graphRequest.get('/me/accounts?limit=100', accessToken);\n  return response.data.map(function (page) {\n    return {\n      id: page.id,\n      name: page.name\n    };\n  });\n};\n\nvar SaveWebhookResponse = function () {\n  function SaveWebhookResponse(userAccessToken, integration, data) {\n    (0, _classCallCheck3.default)(this, SaveWebhookResponse);\n    this.userAccessToken = userAccessToken;\n    this.integration = integration; // received facebook data\n\n    this.data = data;\n    this.currentPageId = null;\n  }\n\n  SaveWebhookResponse.prototype.start = function () {\n    function start() {\n      var _this = this;\n\n      var data = this.data;\n      var integration = this.integration;\n\n      if (data.object === 'page') {\n        data.entry.forEach(function (entry) {\n          // check receiving page is in integration's page list\n          if (!integration.facebookData.pageIds.includes(entry.id)) {\n            return;\n          } // set current page\n\n\n          _this.currentPageId = entry.id; // receive new messenger message\n\n          if (entry.messaging) {\n            _this.viaMessengerEvent(entry);\n          } // receive new feed\n\n\n          if (entry.changes) {\n            _this.viaFeedEvent(entry);\n          }\n        });\n      }\n    }\n\n    return start;\n  }(); // via page messenger\n\n\n  SaveWebhookResponse.prototype.viaMessengerEvent = function () {\n    function viaMessengerEvent(entry) {\n      var _this2 = this;\n\n      entry.messaging.forEach(function (messagingEvent) {\n        // someone sent us a message\n        if (messagingEvent.message) {\n          _this2.getOrCreateConversationByMessenger(messagingEvent);\n        }\n      });\n    }\n\n    return viaMessengerEvent;\n  }(); // wall post\n\n\n  SaveWebhookResponse.prototype.viaFeedEvent = function () {\n    function viaFeedEvent(entry) {\n      var _this3 = this;\n\n      entry.changes.forEach(function (event) {\n        // someone posted on our wall\n        _this3.getOrCreateConversationByFeed(event.value);\n      });\n    }\n\n    return viaFeedEvent;\n  }(); // common get or create conversation helper using both in messenger and feed\n\n\n  SaveWebhookResponse.prototype.getOrCreateConversation = function () {\n    function getOrCreateConversation(params) {\n      // extract params\n      var findSelector = params.findSelector,\n          status = params.status,\n          senderId = params.senderId,\n          facebookData = params.facebookData,\n          content = params.content,\n          attachments = params.attachments,\n          msgFacebookData = params.msgFacebookData;\n      var conversation = Conversations.findOne((0, _extends3.default)({}, findSelector)); // create new conversation\n\n      if (!conversation) {\n        var conversationId = Conversations.insert({\n          integrationId: this.integration._id,\n          customerId: this.getOrCreateCustomer(senderId),\n          status: status,\n          content: content,\n          // save facebook infos\n          facebookData: (0, _extends3.default)({}, facebookData, {\n            pageId: this.currentPageId\n          })\n        });\n        conversation = Conversations.findOne(conversationId); // update conversation\n      } else {\n        Conversations.update({\n          _id: conversation._id\n        }, {\n          $set: {\n            // reset read history\n            readUserIds: [],\n            // if closed, reopen it\n            status: CONVERSATION_STATUSES.OPEN\n          }\n        });\n      } // create new message\n\n\n      this.createMessage({\n        conversation: conversation,\n        userId: senderId,\n        content: content,\n        attachments: attachments,\n        facebookData: msgFacebookData\n      });\n    }\n\n    return getOrCreateConversation;\n  }(); // get or create new conversation by feed info\n\n\n  SaveWebhookResponse.prototype.getOrCreateConversationByFeed = function () {\n    function getOrCreateConversationByFeed(value) {\n      var commentId = value.comment_id; // collect only added actions\n\n      if (value.verb !== 'add') {\n        return;\n      } // ignore duplicated action when like\n\n\n      if (value.verb === 'add' && value.item === 'like') {\n        return;\n      } // if this is already saved then ignore it\n\n\n      if (commentId && Messages.findOne({\n        'facebookData.commentId': commentId\n      })) {\n        return;\n      }\n\n      var senderName = value.sender_name; // sender_id is giving number values when feed and giving string value\n      // when messenger. customer.facebookData.senderId has type of string so\n      // convert it to string\n\n      var senderId = value.sender_id.toString();\n      var messageText = value.message; // when photo, video share, there will be no text, so link instead\n\n      if (!messageText && value.link) {\n        messageText = value.link;\n      } // when situations like checkin, there will be no text and no link\n      // if so ignore it\n\n\n      if (!messageText) {\n        return;\n      } // value.post_id is returning different value even though same post\n      // with the previous one. So fetch post info via graph api and\n      // save returned value. This value will always be the same\n\n\n      var postId = value.post_id; // get page access token\n\n      var response = graphRequest.get(this.currentPageId + \"/?fields=access_token\", this.userAccessToken); // acess token expired\n\n      if (response === 'Error processing https request') {\n        return;\n      } // get post object\n\n\n      response = graphRequest.get(postId, response.access_token);\n      postId = response.id;\n      var status = CONVERSATION_STATUSES.NEW; // if we are posting from our page, close it automatically\n\n      if (this.integration.facebookData.pageIds.includes(senderId)) {\n        status = CONVERSATION_STATUSES.CLOSED;\n      }\n\n      this.getOrCreateConversation({\n        findSelector: {\n          'facebookData.kind': FACEBOOK_DATA_KINDS.FEED,\n          'facebookData.postId': postId\n        },\n        status: status,\n        senderId: senderId,\n        facebookData: {\n          kind: FACEBOOK_DATA_KINDS.FEED,\n          senderId: senderId,\n          senderName: senderName,\n          postId: postId\n        },\n        // message data\n        content: messageText,\n        msgFacebookData: {\n          senderId: senderId,\n          senderName: senderName,\n          item: value.item,\n          reactionType: value.reaction_type,\n          photoId: value.photo_id,\n          videoId: value.video_id,\n          link: value.link\n        }\n      });\n    }\n\n    return getOrCreateConversationByFeed;\n  }(); // get or create new conversation by page messenger\n\n\n  SaveWebhookResponse.prototype.getOrCreateConversationByMessenger = function () {\n    function getOrCreateConversationByMessenger(event) {\n      var senderId = event.sender.id;\n      var senderName = event.sender.name;\n      var recipientId = event.recipient.id;\n      var messageText = event.message.text || 'attachment'; // collect attachment's url, type fields\n\n      var attachments = (event.message.attachments || []).map(function (attachment) {\n        return {\n          type: attachment.type,\n          url: attachment.payload.url\n        };\n      });\n      this.getOrCreateConversation({\n        // try to find conversation by senderId, recipientId keys\n        findSelector: {\n          'facebookData.kind': FACEBOOK_DATA_KINDS.MESSENGER,\n          $or: [{\n            'facebookData.senderId': senderId,\n            'facebookData.recipientId': recipientId\n          }, {\n            'facebookData.senderId': recipientId,\n            'facebookData.recipientId': senderId\n          }]\n        },\n        status: CONVERSATION_STATUSES.NEW,\n        senderId: senderId,\n        facebookData: {\n          kind: FACEBOOK_DATA_KINDS.MESSENGER,\n          senderId: senderId,\n          senderName: senderName,\n          recipientId: recipientId\n        },\n        // message data\n        content: messageText,\n        attachments: attachments,\n        msgFacebookData: {}\n      });\n    }\n\n    return getOrCreateConversationByMessenger;\n  }(); // get or create customer using facebook data\n\n\n  SaveWebhookResponse.prototype.getOrCreateCustomer = function () {\n    function getOrCreateCustomer(fbUserId) {\n      var integrationId = this.integration._id;\n      var customer = Customers.findOne({\n        integrationId: integrationId,\n        'facebookData.id': fbUserId\n      });\n\n      if (customer) {\n        return customer._id;\n      } // get page access token\n\n\n      var res = graphRequest.get(this.currentPageId + \"/?fields=access_token\", this.userAccessToken); // get user info\n\n      res = graphRequest.get(\"/\" + fbUserId, res.access_token); // when feed response will contain name field\n      // when messeger response will not contain name field\n\n      var name = res.name || res.first_name + \" \" + res.last_name; // create customer\n\n      return Customers.insert({\n        name: name,\n        integrationId: integrationId,\n        facebookData: {\n          id: fbUserId,\n          profilePic: res.profile_pic\n        }\n      });\n    }\n\n    return getOrCreateCustomer;\n  }();\n\n  SaveWebhookResponse.prototype.createMessage = function () {\n    function createMessage(_ref) {\n      var conversation = _ref.conversation,\n          userId = _ref.userId,\n          content = _ref.content,\n          attachments = _ref.attachments,\n          facebookData = _ref.facebookData;\n\n      if (conversation) {\n        // create new message\n        var messageId = Messages.insert({\n          conversationId: conversation._id,\n          customerId: this.getOrCreateCustomer(userId),\n          content: content,\n          attachments: attachments,\n          facebookData: facebookData,\n          internal: false\n        }); // notify subscription server new message\n\n        apolloNotifyNewMessage(messageId);\n        return messageId;\n      }\n    }\n\n    return createMessage;\n  }();\n\n  return SaveWebhookResponse;\n}();\n\nvar receiveWebhookResponse = function (app, data) {\n  var selector = {\n    kind: KIND_CHOICES.FACEBOOK,\n    'facebookData.appId': app.id\n  };\n  Integrations.find(selector).forEach(function (integration) {\n    // when new message or other kind of activity in page\n    var saveWebhookResponse = new SaveWebhookResponse(app.accessToken, integration, data);\n    saveWebhookResponse.start();\n  });\n};\n\nMeteor.settings.services.facebook.forEach(function (app) {\n  Picker.route(\"/service/facebook/\" + app.id + \"/webhook-callback\", function (params, req, res) {\n    var query = params.query; // when the endpoint is registered as a webhook, it must echo back\n    // the 'hub.challenge' value it receives in the query arguments\n\n    if (query['hub.mode'] === 'subscribe' && query['hub.challenge']) {\n      if (query['hub.verify_token'] !== app.verifyToken) {\n        res.end('Verification token mismatch');\n      }\n\n      res.end(query['hub.challenge']);\n    }\n\n    res.statusCode = 200; // receive per app webhook response\n\n    receiveWebhookResponse(app, req.body);\n    res.end('success');\n  });\n}); /*\n     * post reply to page conversation or comment to wall post\n     */\n\nvar facebookReply = function (conversation, text, messageId) {\n  var app = Meteor.settings.services.facebook.find(function (a) {\n    return a.id === conversation.integration().facebookData.appId;\n  }); // page access token\n\n  var response = graphRequest.get(conversation.facebookData.pageId + \"/?fields=access_token\", app.accessToken); // messenger reply\n\n  if (conversation.facebookData.kind === FACEBOOK_DATA_KINDS.MESSENGER) {\n    return graphRequest.post('me/messages', response.access_token, {\n      recipient: {\n        id: conversation.facebookData.senderId\n      },\n      message: {\n        text: text\n      }\n    }, function () {});\n  } // feed reply\n\n\n  if (conversation.facebookData.kind === FACEBOOK_DATA_KINDS.FEED) {\n    var postId = conversation.facebookData.postId; // post reply\n\n    var commentResponse = graphRequest.post(postId + \"/comments\", response.access_token, {\n      message: text\n    }); // save commentId in message object\n\n    Messages.update({\n      _id: messageId\n    }, {\n      $set: {\n        'facebookData.commentId': commentResponse.id\n      }\n    });\n  }\n\n  return null;\n};","map":{"version":3,"sources":["/imports/api/integrations/social/server/facebook.js"],"names":["module","export","graphRequest","getPageList","SaveWebhookResponse","receiveWebhookResponse","facebookReply","graph","importSync","v","Picker","Meteor","apolloNotifyNewMessage","Conversations","Messages","Customers","Integrations","KIND_CHOICES","CONVERSATION_STATUSES","FACEBOOK_DATA_KINDS","base","method","path","accessToken","setAccessToken","wrappedGraph","wrapAsync","otherParams","e","console","log","message","get","args","post","response","data","map","id","page","name","userAccessToken","integration","currentPageId","start","object","entry","forEach","facebookData","pageIds","includes","messaging","viaMessengerEvent","changes","viaFeedEvent","messagingEvent","getOrCreateConversationByMessenger","getOrCreateConversationByFeed","event","value","getOrCreateConversation","params","findSelector","status","senderId","content","attachments","msgFacebookData","conversation","findOne","conversationId","insert","integrationId","_id","customerId","getOrCreateCustomer","pageId","update","$set","readUserIds","OPEN","createMessage","userId","commentId","comment_id","verb","item","senderName","sender_name","sender_id","toString","messageText","link","postId","post_id","access_token","NEW","CLOSED","FEED","kind","reactionType","reaction_type","photoId","photo_id","videoId","video_id","sender","recipientId","recipient","text","type","attachment","url","payload","MESSENGER","$or","fbUserId","customer","res","first_name","last_name","profilePic","profile_pic","messageId","internal","app","selector","FACEBOOK","find","saveWebhookResponse","settings","services","facebook","route","req","query","verifyToken","end","statusCode","body","a","appId","commentResponse"],"mappings":"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","file":"/imports/api/integrations/social/server/facebook.js.map","sourcesContent":["import graph from 'fbgraph';\nimport { Picker } from 'meteor/meteorhacks:picker';\nimport { Meteor } from 'meteor/meteor';\nimport { apolloNotifyNewMessage } from '/imports/api/server/utils';\nimport { Conversations } from '/imports/api/conversations/conversations';\nimport { Messages } from '/imports/api/conversations/messages';\nimport { Customers } from '/imports/api/customers/customers';\nimport { Integrations } from '/imports/api/integrations/integrations';\nimport { KIND_CHOICES } from '/imports/api/integrations/constants';\nimport { CONVERSATION_STATUSES, FACEBOOK_DATA_KINDS } from '/imports/api/conversations/constants';\n\n/*\n * Common graph api request wrapper\n * catchs auth token or other type of exceptions\n */\nexport const graphRequest = {\n  base(method, path, accessToken, ...otherParams) {\n    // set access token\n    graph.setAccessToken(accessToken);\n\n    const wrappedGraph = Meteor.wrapAsync(graph[method], graph);\n\n    try {\n      return wrappedGraph(path, ...otherParams);\n\n      // catch session expired or some other error\n    } catch (e) {\n      console.log(e.message); // eslint-disable-line no-console\n      return e.message;\n    }\n  },\n\n  get(...args) {\n    return this.base('get', ...args);\n  },\n\n  post(...args) {\n    return this.base('post', ...args);\n  },\n};\n\n/*\n * get list of pages that authorized user owns\n */\nexport const getPageList = accessToken => {\n  const response = graphRequest.get('/me/accounts?limit=100', accessToken);\n\n  return response.data.map(page => ({\n    id: page.id,\n    name: page.name,\n  }));\n};\n\n/*\n * save webhook response\n * create conversation, customer, message using transmitted data\n */\n\nexport class SaveWebhookResponse {\n  constructor(userAccessToken, integration, data) {\n    this.userAccessToken = userAccessToken;\n\n    this.integration = integration;\n\n    // received facebook data\n    this.data = data;\n\n    this.currentPageId = null;\n  }\n\n  start() {\n    const data = this.data;\n    const integration = this.integration;\n\n    if (data.object === 'page') {\n      data.entry.forEach(entry => {\n        // check receiving page is in integration's page list\n        if (!integration.facebookData.pageIds.includes(entry.id)) {\n          return;\n        }\n\n        // set current page\n        this.currentPageId = entry.id;\n\n        // receive new messenger message\n        if (entry.messaging) {\n          this.viaMessengerEvent(entry);\n        }\n\n        // receive new feed\n        if (entry.changes) {\n          this.viaFeedEvent(entry);\n        }\n      });\n    }\n  }\n\n  // via page messenger\n  viaMessengerEvent(entry) {\n    entry.messaging.forEach(messagingEvent => {\n      // someone sent us a message\n      if (messagingEvent.message) {\n        this.getOrCreateConversationByMessenger(messagingEvent);\n      }\n    });\n  }\n\n  // wall post\n  viaFeedEvent(entry) {\n    entry.changes.forEach(event => {\n      // someone posted on our wall\n      this.getOrCreateConversationByFeed(event.value);\n    });\n  }\n\n  // common get or create conversation helper using both in messenger and feed\n  getOrCreateConversation(params) {\n    // extract params\n    const {\n      findSelector,\n      status,\n      senderId,\n      facebookData,\n      content,\n      attachments,\n      msgFacebookData,\n    } = params;\n\n    let conversation = Conversations.findOne({\n      ...findSelector,\n    });\n\n    // create new conversation\n    if (!conversation) {\n      const conversationId = Conversations.insert({\n        integrationId: this.integration._id,\n        customerId: this.getOrCreateCustomer(senderId),\n        status,\n        content,\n\n        // save facebook infos\n        facebookData: {\n          ...facebookData,\n          pageId: this.currentPageId,\n        },\n      });\n      conversation = Conversations.findOne(conversationId);\n\n      // update conversation\n    } else {\n      Conversations.update(\n        { _id: conversation._id },\n        {\n          $set: {\n            // reset read history\n            readUserIds: [],\n\n            // if closed, reopen it\n            status: CONVERSATION_STATUSES.OPEN,\n          },\n        },\n      );\n    }\n\n    // create new message\n    this.createMessage({\n      conversation,\n      userId: senderId,\n      content,\n      attachments,\n      facebookData: msgFacebookData,\n    });\n  }\n\n  // get or create new conversation by feed info\n  getOrCreateConversationByFeed(value) {\n    const commentId = value.comment_id;\n\n    // collect only added actions\n    if (value.verb !== 'add') {\n      return;\n    }\n\n    // ignore duplicated action when like\n    if (value.verb === 'add' && value.item === 'like') {\n      return;\n    }\n\n    // if this is already saved then ignore it\n    if (commentId && Messages.findOne({ 'facebookData.commentId': commentId })) {\n      return;\n    }\n\n    const senderName = value.sender_name;\n\n    // sender_id is giving number values when feed and giving string value\n    // when messenger. customer.facebookData.senderId has type of string so\n    // convert it to string\n    const senderId = value.sender_id.toString();\n\n    let messageText = value.message;\n\n    // when photo, video share, there will be no text, so link instead\n    if (!messageText && value.link) {\n      messageText = value.link;\n    }\n\n    // when situations like checkin, there will be no text and no link\n    // if so ignore it\n    if (!messageText) {\n      return;\n    }\n\n    // value.post_id is returning different value even though same post\n    // with the previous one. So fetch post info via graph api and\n    // save returned value. This value will always be the same\n    let postId = value.post_id;\n\n    // get page access token\n    let response = graphRequest.get(\n      `${this.currentPageId}/?fields=access_token`,\n      this.userAccessToken,\n    );\n\n    // acess token expired\n    if (response === 'Error processing https request') {\n      return;\n    }\n\n    // get post object\n    response = graphRequest.get(postId, response.access_token);\n\n    postId = response.id;\n\n    let status = CONVERSATION_STATUSES.NEW;\n\n    // if we are posting from our page, close it automatically\n    if (this.integration.facebookData.pageIds.includes(senderId)) {\n      status = CONVERSATION_STATUSES.CLOSED;\n    }\n\n    this.getOrCreateConversation({\n      findSelector: {\n        'facebookData.kind': FACEBOOK_DATA_KINDS.FEED,\n        'facebookData.postId': postId,\n      },\n      status,\n      senderId,\n      facebookData: {\n        kind: FACEBOOK_DATA_KINDS.FEED,\n        senderId,\n        senderName,\n        postId,\n      },\n\n      // message data\n      content: messageText,\n      msgFacebookData: {\n        senderId,\n        senderName,\n        item: value.item,\n        reactionType: value.reaction_type,\n        photoId: value.photo_id,\n        videoId: value.video_id,\n        link: value.link,\n      },\n    });\n  }\n\n  // get or create new conversation by page messenger\n  getOrCreateConversationByMessenger(event) {\n    const senderId = event.sender.id;\n    const senderName = event.sender.name;\n    const recipientId = event.recipient.id;\n    const messageText = event.message.text || 'attachment';\n\n    // collect attachment's url, type fields\n    const attachments = (event.message.attachments || []).map(attachment => ({\n      type: attachment.type,\n      url: attachment.payload.url,\n    }));\n\n    this.getOrCreateConversation({\n      // try to find conversation by senderId, recipientId keys\n      findSelector: {\n        'facebookData.kind': FACEBOOK_DATA_KINDS.MESSENGER,\n        $or: [\n          {\n            'facebookData.senderId': senderId,\n            'facebookData.recipientId': recipientId,\n          },\n          {\n            'facebookData.senderId': recipientId,\n            'facebookData.recipientId': senderId,\n          },\n        ],\n      },\n      status: CONVERSATION_STATUSES.NEW,\n      senderId,\n      facebookData: {\n        kind: FACEBOOK_DATA_KINDS.MESSENGER,\n        senderId,\n        senderName,\n        recipientId,\n      },\n\n      // message data\n      content: messageText,\n      attachments,\n      msgFacebookData: {},\n    });\n  }\n\n  // get or create customer using facebook data\n  getOrCreateCustomer(fbUserId) {\n    const integrationId = this.integration._id;\n\n    const customer = Customers.findOne({\n      integrationId,\n      'facebookData.id': fbUserId,\n    });\n\n    if (customer) {\n      return customer._id;\n    }\n\n    // get page access token\n    let res = graphRequest.get(`${this.currentPageId}/?fields=access_token`, this.userAccessToken);\n\n    // get user info\n    res = graphRequest.get(`/${fbUserId}`, res.access_token);\n\n    // when feed response will contain name field\n    // when messeger response will not contain name field\n    const name = res.name || `${res.first_name} ${res.last_name}`;\n\n    // create customer\n    return Customers.insert({\n      name,\n      integrationId,\n      facebookData: {\n        id: fbUserId,\n        profilePic: res.profile_pic,\n      },\n    });\n  }\n\n  createMessage({ conversation, userId, content, attachments, facebookData }) {\n    if (conversation) {\n      // create new message\n      const messageId = Messages.insert({\n        conversationId: conversation._id,\n        customerId: this.getOrCreateCustomer(userId),\n        content,\n        attachments,\n        facebookData,\n        internal: false,\n      });\n\n      // notify subscription server new message\n      apolloNotifyNewMessage(messageId);\n\n      return messageId;\n    }\n  }\n}\n\n/*\n * receive per app webhook response\n */\nexport const receiveWebhookResponse = (app, data) => {\n  const selector = {\n    kind: KIND_CHOICES.FACEBOOK,\n    'facebookData.appId': app.id,\n  };\n\n  Integrations.find(selector).forEach(integration => {\n    // when new message or other kind of activity in page\n    const saveWebhookResponse = new SaveWebhookResponse(app.accessToken, integration, data);\n\n    saveWebhookResponse.start();\n  });\n};\n\nMeteor.settings.services.facebook.forEach(app => {\n  Picker.route(`/service/facebook/${app.id}/webhook-callback`, (params, req, res) => {\n    const query = params.query;\n\n    // when the endpoint is registered as a webhook, it must echo back\n    // the 'hub.challenge' value it receives in the query arguments\n    if (query['hub.mode'] === 'subscribe' && query['hub.challenge']) {\n      if (query['hub.verify_token'] !== app.verifyToken) {\n        res.end('Verification token mismatch');\n      }\n\n      res.end(query['hub.challenge']);\n    }\n\n    res.statusCode = 200;\n\n    // receive per app webhook response\n    receiveWebhookResponse(app, req.body);\n\n    res.end('success');\n  });\n});\n\n/*\n * post reply to page conversation or comment to wall post\n */\nexport const facebookReply = (conversation, text, messageId) => {\n  const app = Meteor.settings.services.facebook.find(\n    a => a.id === conversation.integration().facebookData.appId,\n  );\n\n  // page access token\n  const response = graphRequest.get(\n    `${conversation.facebookData.pageId}/?fields=access_token`,\n    app.accessToken,\n  );\n\n  // messenger reply\n  if (conversation.facebookData.kind === FACEBOOK_DATA_KINDS.MESSENGER) {\n    return graphRequest.post(\n      'me/messages',\n      response.access_token,\n      {\n        recipient: { id: conversation.facebookData.senderId },\n        message: { text },\n      },\n      () => {},\n    );\n  }\n\n  // feed reply\n  if (conversation.facebookData.kind === FACEBOOK_DATA_KINDS.FEED) {\n    const postId = conversation.facebookData.postId;\n\n    // post reply\n    const commentResponse = graphRequest.post(`${postId}/comments`, response.access_token, {\n      message: text,\n    });\n\n    // save commentId in message object\n    Messages.update({ _id: messageId }, { $set: { 'facebookData.commentId': commentResponse.id } });\n  }\n\n  return null;\n};\n"]},"hash":"06e54a58aa013c3f9b70d58c4a43dcc6f748d6a0"}
