{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/mdg:validated-method/validated-method-tests.js","filenameRelative":"/packages/mdg:validated-method/validated-method-tests.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/mdg:validated-method/validated-method-tests.js.map","sourceFileName":"/packages/mdg:validated-method/validated-method-tests.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"validated-method-tests"},"ignored":false,"code":"var plainMethod = new ValidatedMethod({\n  name: 'plainMethod',\n  validate: new SimpleSchema({}).validator(),\n  run: function () {\n    return 'result';\n  }\n});\nvar noArgsMethod = new ValidatedMethod({\n  name: 'noArgsMethod',\n  validate: null,\n  run: function () {\n    return 'result';\n  }\n});\nvar methodWithArgs = new ValidatedMethod({\n  name: 'methodWithArgs',\n  validate: new SimpleSchema({\n    int: {\n      type: Number\n    },\n    string: {\n      type: String\n    }\n  }).validator(),\n  run: function () {\n    return 'result';\n  }\n});\nvar methodThrowsImmediately = new ValidatedMethod({\n  name: 'methodThrowsImmediately',\n  validate: null,\n  run: function () {\n    throw new Meteor.Error('error');\n  }\n});\nvar methodReturnsName = new ValidatedMethod({\n  name: 'methodReturnsName',\n  validate: null,\n  run: function () {\n    return this.name;\n  }\n});\nvar methodWithSchemaMixin = new ValidatedMethod({\n  name: 'methodWithSchemaMixin',\n  mixins: [schemaMixin],\n  schema: new SimpleSchema({\n    int: {\n      type: Number\n    },\n    string: {\n      type: String\n    }\n  }),\n  run: function () {\n    return 'result';\n  }\n});\nvar resultReceived = false;\nvar methodWithApplyOptions = new ValidatedMethod({\n  name: 'methodWithApplyOptions',\n  validate: new SimpleSchema({}).validator(),\n  applyOptions: {\n    onResultReceived: function () {\n      resultReceived = true;\n    }\n  },\n  run: function () {\n    return 'result';\n  }\n});\n\nfunction schemaMixin(methodOptions) {\n  methodOptions.validate = methodOptions.schema.validator();\n  return methodOptions;\n}\n\ndescribe('mdg:method', function () {\n  it('defines a method that can be called', function (done) {\n    plainMethod.call({}, function (error, result) {\n      assert.equal(result, 'result');\n      Meteor.call(plainMethod.name, {}, function (error, result) {\n        assert.equal(result, 'result');\n        done();\n      });\n    });\n  });\n  it('allows methods that take no arguments', function (done) {\n    noArgsMethod.call(function (error, result) {\n      assert.equal(result, 'result');\n      Meteor.call(noArgsMethod.name, function (error, result) {\n        assert.equal(result, 'result');\n        done();\n      });\n    });\n  });\n  it('checks schema', function (done) {\n    [methodWithArgs, methodWithSchemaMixin].forEach(function (method) {\n      method.call({}, function (error, result) {\n        // 2 invalid fields\n        assert.equal(error.errors.length, 2);\n        method.call({\n          int: 5,\n          string: \"what\"\n        }, function (error, result) {\n          // All good!\n          assert.equal(result, 'result');\n          done();\n        });\n      });\n    });\n  });\n  it('throws error if no callback passed', function (done) {\n    methodThrowsImmediately.call({}, function (err) {\n      // If you pass a callback, you get the error in the callback\n      assert.ok(err); // If no callback, the error is thrown\n\n      assert.throws(function () {\n        methodThrowsImmediately.call({});\n      }, /error/);\n      done();\n    });\n  });\n  it('throws error if a mixin does not return the options object', function () {\n    assert.throws(function () {\n      new ValidatedMethod({\n        name: 'methodWithFaultySchemaMixin',\n        mixins: [function () {\n          function nonReturningFunction() {}\n\n          return nonReturningFunction;\n        }()],\n        schema: null,\n        run: function () {\n          return 'result';\n        }\n      });\n    }, /Error in methodWithFaultySchemaMixin method: The function 'nonReturningFunction' didn't return the options object/);\n    assert.throws(function () {\n      new ValidatedMethod({\n        name: 'methodWithFaultySchemaMixin',\n        mixins: [function (args) {\n          return args;\n        }, function () {}],\n        schema: null,\n        run: function () {\n          return 'result';\n        }\n      });\n    }, /Error in methodWithFaultySchemaMixin method: One of the mixins didn't return the options object/);\n  });\n  it('has access to the name on this.name', function (done) {\n    var ret = methodReturnsName._execute();\n\n    assert.equal(ret, 'methodReturnsName');\n    methodReturnsName.call({}, function (err, res) {\n      // The Method knows its own name\n      assert.equal(res, 'methodReturnsName');\n      done();\n    });\n  });\n  it('can accept Meteor.apply options', function (done) {\n    if (Meteor.isServer) {\n      // the only apply option that I can think of to test is client side only\n      return done();\n    }\n\n    resultReceived = false;\n    methodWithApplyOptions.call({}, function (err, res) {\n      // The Method knows its own name\n      assert.equal(resultReceived, true);\n      done();\n    });\n  });\n});","map":{"version":3,"sources":["/packages/mdg:validated-method/validated-method-tests.js"],"names":["plainMethod","ValidatedMethod","name","validate","SimpleSchema","validator","run","noArgsMethod","methodWithArgs","int","type","Number","string","String","methodThrowsImmediately","Meteor","Error","methodReturnsName","methodWithSchemaMixin","mixins","schemaMixin","schema","resultReceived","methodWithApplyOptions","applyOptions","onResultReceived","methodOptions","describe","it","done","call","error","result","assert","equal","forEach","method","errors","length","err","ok","throws","nonReturningFunction","args","ret","_execute","res","isServer"],"mappings":"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","file":"/packages/mdg:validated-method/validated-method-tests.js.map","sourcesContent":["const plainMethod = new ValidatedMethod({\n  name: 'plainMethod',\n  validate: new SimpleSchema({}).validator(),\n  run() {\n    return 'result';\n  }\n});\n\nconst noArgsMethod = new ValidatedMethod({\n  name: 'noArgsMethod',\n  validate: null,\n  run() {\n    return 'result';\n  }\n});\n\nconst methodWithArgs = new ValidatedMethod({\n  name: 'methodWithArgs',\n  validate: new SimpleSchema({\n    int: { type: Number },\n    string: { type: String },\n  }).validator(),\n  run() {\n    return 'result';\n  }\n});\n\nconst methodThrowsImmediately = new ValidatedMethod({\n  name: 'methodThrowsImmediately',\n  validate: null,\n  run() {\n    throw new Meteor.Error('error');\n  }\n});\n\nconst methodReturnsName = new ValidatedMethod({\n  name: 'methodReturnsName',\n  validate: null,\n  run() {\n    return this.name;\n  }\n});\n\nconst methodWithSchemaMixin = new ValidatedMethod({\n  name: 'methodWithSchemaMixin',\n  mixins: [schemaMixin],\n  schema: new SimpleSchema({\n    int: { type: Number },\n    string: { type: String },\n  }),\n  run() {\n    return 'result';\n  }\n});\n\nlet resultReceived = false;\nconst methodWithApplyOptions = new ValidatedMethod({\n  name: 'methodWithApplyOptions',\n  validate: new SimpleSchema({}).validator(),\n  applyOptions: {\n    onResultReceived: function() {\n      resultReceived = true;\n    }\n  },\n  run() {\n    return 'result';\n  }\n});\n\nfunction schemaMixin(methodOptions) {\n  methodOptions.validate = methodOptions.schema.validator();\n  return methodOptions;\n}\n\ndescribe('mdg:method', () => {\n  it('defines a method that can be called', (done) => {\n    plainMethod.call({}, (error, result) => {\n      assert.equal(result, 'result');\n\n      Meteor.call(plainMethod.name, {}, (error, result) => {\n        assert.equal(result, 'result');\n        done();\n      });\n    });\n  });\n\n  it('allows methods that take no arguments', (done) => {\n    noArgsMethod.call((error, result) => {\n      assert.equal(result, 'result');\n\n      Meteor.call(noArgsMethod.name, (error, result) => {\n        assert.equal(result, 'result');\n        done();\n      });\n    });\n  });\n\n  it('checks schema', (done) => {\n    [methodWithArgs, methodWithSchemaMixin].forEach((method) => {\n      method.call({}, (error, result) => {\n        // 2 invalid fields\n        assert.equal(error.errors.length, 2);\n\n        method.call({\n          int: 5,\n          string: \"what\",\n        }, (error, result) => {\n          // All good!\n          assert.equal(result, 'result');\n\n          done();\n        });\n      });\n    });\n  });\n\n  it('throws error if no callback passed', (done) => {\n    methodThrowsImmediately.call({}, (err) => {\n      // If you pass a callback, you get the error in the callback\n      assert.ok(err);\n\n      // If no callback, the error is thrown\n      assert.throws(() => {\n        methodThrowsImmediately.call({});\n      }, /error/);\n\n      done();\n    });\n  });\n\n  it('throws error if a mixin does not return the options object', () => {\n    assert.throws(() => {\n      new ValidatedMethod({\n        name: 'methodWithFaultySchemaMixin',\n        mixins: [function nonReturningFunction() {}],\n        schema: null,\n        run() {\n          return 'result';\n        }\n      });\n    }, /Error in methodWithFaultySchemaMixin method: The function 'nonReturningFunction' didn't return the options object/);\n\n    assert.throws(() => {\n      new ValidatedMethod({\n        name: 'methodWithFaultySchemaMixin',\n        mixins: [function (args) { return args}, function () {}],\n        schema: null,\n        run() {\n          return 'result';\n        }\n      });\n    }, /Error in methodWithFaultySchemaMixin method: One of the mixins didn't return the options object/);\n  });\n\n  it('has access to the name on this.name', (done) => {\n    const ret = methodReturnsName._execute();\n    assert.equal(ret, 'methodReturnsName');\n\n    methodReturnsName.call({}, (err, res) => {\n      // The Method knows its own name\n      assert.equal(res, 'methodReturnsName');\n\n      done();\n    });\n  });\n\n  it('can accept Meteor.apply options', (done) => {\n    if (Meteor.isServer) {\n      // the only apply option that I can think of to test is client side only\n      return done();\n    }\n\n    resultReceived = false;\n    methodWithApplyOptions.call({}, (err, res) => {\n      // The Method knows its own name\n      assert.equal(resultReceived, true);\n\n      done();\n    });\n  });\n});\n"]},"hash":"cd52da75dd08fa068b84a2fbfceab3a6b4916876"}
