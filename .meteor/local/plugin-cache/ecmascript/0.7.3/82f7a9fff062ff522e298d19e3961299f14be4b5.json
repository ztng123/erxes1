{"metadata":{"usedHelpers":["inherits","possibleConstructorReturn","classCallCheck","interopRequireDefault"],"marked":[],"modules":{"imports":[{"source":"./accounts_common.js","imported":["AccountsCommon"],"specifiers":[{"kind":"named","imported":"AccountsCommon","local":"AccountsCommon"}]}],"exports":{"exported":["AccountsClient"],"specifiers":[{"kind":"local","local":"AccountsClient","exported":"AccountsClient"}]}}},"options":{"filename":"/packages/accounts-base/accounts_client.js","filenameRelative":"/packages/accounts-base/accounts_client.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/accounts-base/accounts_client.js.map","sourceFileName":"/packages/accounts-base/accounts_client.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"accounts_client"},"ignored":false,"code":"var _classCallCheck2 = require(\"babel-runtime/helpers/classCallCheck\");\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _possibleConstructorReturn2 = require(\"babel-runtime/helpers/possibleConstructorReturn\");\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require(\"babel-runtime/helpers/inherits\");\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nmodule.export({\n  AccountsClient: function () {\n    return AccountsClient;\n  }\n});\nvar AccountsCommon = void 0;\nmodule.importSync(\"./accounts_common.js\", {\n  AccountsCommon: function (v) {\n    AccountsCommon = v;\n  }\n}, 0);\n\nvar AccountsClient = function (_AccountsCommon) {\n  (0, _inherits3.default)(AccountsClient, _AccountsCommon);\n\n  function AccountsClient(options) {\n    (0, _classCallCheck3.default)(this, AccountsClient);\n\n    var _this = (0, _possibleConstructorReturn3.default)(this, _AccountsCommon.call(this, options));\n\n    _this._loggingIn = new ReactiveVar(false);\n    _this._loggingOut = new ReactiveVar(false);\n    _this._loginServicesHandle = _this.connection.subscribe(\"meteor.loginServiceConfiguration\");\n    _this._pageLoadLoginCallbacks = [];\n    _this._pageLoadLoginAttemptInfo = null; // Defined in url_client.js.\n\n    _this._initUrlMatching(); // Defined in localstorage_token.js.\n\n\n    _this._initLocalStorage();\n\n    return _this;\n  } ///\n  /// CURRENT USER\n  ///\n  // @override\n\n\n  AccountsClient.prototype.userId = function () {\n    function userId() {\n      return this.connection.userId();\n    }\n\n    return userId;\n  }(); // This is mostly just called within this file, but Meteor.loginWithPassword\n  // also uses it to make loggingIn() be true during the beginPasswordExchange\n  // method call too.\n\n\n  AccountsClient.prototype._setLoggingIn = function () {\n    function _setLoggingIn(x) {\n      this._loggingIn.set(x);\n    }\n\n    return _setLoggingIn;\n  }(); /**\n        * @summary True if a login method (such as `Meteor.loginWithPassword`, `Meteor.loginWithFacebook`, or `Accounts.createUser`) is currently in progress. A reactive data source.\n        * @locus Client\n        */\n\n  AccountsClient.prototype.loggingIn = function () {\n    function loggingIn() {\n      return this._loggingIn.get();\n    }\n\n    return loggingIn;\n  }(); /**\n        * @summary True if a logout method (such as `Meteor.logout`) is currently in progress. A reactive data source.\n        * @locus Client\n        */\n\n  AccountsClient.prototype.loggingOut = function () {\n    function loggingOut() {\n      return this._loggingOut.get();\n    }\n\n    return loggingOut;\n  }(); /**\n        * @summary Log the user out.\n        * @locus Client\n        * @param {Function} [callback] Optional callback. Called with no arguments on success, or with a single `Error` argument on failure.\n        */\n\n  AccountsClient.prototype.logout = function () {\n    function logout(callback) {\n      var self = this;\n\n      self._loggingOut.set(true);\n\n      self.connection.apply('logout', [], {\n        wait: true\n      }, function (error, result) {\n        self._loggingOut.set(false);\n\n        if (error) {\n          callback && callback(error);\n        } else {\n          self.makeClientLoggedOut();\n          callback && callback();\n        }\n      });\n    }\n\n    return logout;\n  }(); /**\n        * @summary Log out other clients logged in as the current user, but does not log out the client that calls this function.\n        * @locus Client\n        * @param {Function} [callback] Optional callback. Called with no arguments on success, or with a single `Error` argument on failure.\n        */\n\n  AccountsClient.prototype.logoutOtherClients = function () {\n    function logoutOtherClients(callback) {\n      var self = this; // We need to make two method calls: one to replace our current token,\n      // and another to remove all tokens except the current one. We want to\n      // call these two methods one after the other, without any other\n      // methods running between them. For example, we don't want `logout`\n      // to be called in between our two method calls (otherwise the second\n      // method call would return an error). Another example: we don't want\n      // logout to be called before the callback for `getNewToken`;\n      // otherwise we would momentarily log the user out and then write a\n      // new token to localStorage.\n      //\n      // To accomplish this, we make both calls as wait methods, and queue\n      // them one after the other, without spinning off the event loop in\n      // between. Even though we queue `removeOtherTokens` before\n      // `getNewToken`, we won't actually send the `removeOtherTokens` call\n      // until the `getNewToken` callback has finished running, because they\n      // are both wait methods.\n\n      self.connection.apply('getNewToken', [], {\n        wait: true\n      }, function (err, result) {\n        if (!err) {\n          self._storeLoginToken(self.userId(), result.token, result.tokenExpires);\n        }\n      });\n      self.connection.apply('removeOtherTokens', [], {\n        wait: true\n      }, function (err) {\n        callback && callback(err);\n      });\n    }\n\n    return logoutOtherClients;\n  }();\n\n  return AccountsClient;\n}(AccountsCommon);\n\n;\nvar Ap = AccountsClient.prototype; /**\n                                    * @summary True if a login method (such as `Meteor.loginWithPassword`, `Meteor.loginWithFacebook`, or `Accounts.createUser`) is currently in progress. A reactive data source.\n                                    * @locus Client\n                                    * @importFromPackage meteor\n                                    */\n\nMeteor.loggingIn = function () {\n  return Accounts.loggingIn();\n}; /**\n    * @summary True if a logout method (such as `Meteor.logout`) is currently in progress. A reactive data source.\n    * @locus Client\n    * @importFromPackage meteor\n    */\n\nMeteor.loggingOut = function () {\n  return Accounts.loggingOut();\n}; ///\n/// LOGIN METHODS\n///\n// Call a login method on the server.\n//\n// A login method is a method which on success calls `this.setUserId(id)` and\n// `Accounts._setLoginToken` on the server and returns an object with fields\n// 'id' (containing the user id), 'token' (containing a resume token), and\n// optionally `tokenExpires`.\n//\n// This function takes care of:\n//   - Updating the Meteor.loggingIn() reactive data source\n//   - Calling the method in 'wait' mode\n//   - On success, saving the resume token to localStorage\n//   - On success, calling Accounts.connection.setUserId()\n//   - Setting up an onReconnect handler which logs in with\n//     the resume token\n//\n// Options:\n// - methodName: The method to call (default 'login')\n// - methodArguments: The arguments for the method\n// - validateResult: If provided, will be called with the result of the\n//                 method. If it throws, the client will not be logged in (and\n//                 its error will be passed to the callback).\n// - userCallback: Will be called with no arguments once the user is fully\n//                 logged in, or with the error on error.\n//\n\n\nAp.callLoginMethod = function (options) {\n  var self = this;\n  options = _.extend({\n    methodName: 'login',\n    methodArguments: [{}],\n    _suppressLoggingIn: false\n  }, options); // Set defaults for callback arguments to no-op functions; make sure we\n  // override falsey values too.\n\n  _.each(['validateResult', 'userCallback'], function (f) {\n    if (!options[f]) options[f] = function () {};\n  }); // Prepare callbacks: user provided and onLogin/onLoginFailure hooks.\n\n\n  var loginCallbacks = _.once(function (error) {\n    if (!error) {\n      self._onLoginHook.each(function (callback) {\n        callback();\n        return true;\n      });\n    } else {\n      self._onLoginFailureHook.each(function (callback) {\n        callback({\n          error: error\n        });\n        return true;\n      });\n    }\n\n    options.userCallback.apply(this, arguments);\n  });\n\n  var reconnected = false; // We want to set up onReconnect as soon as we get a result token back from\n  // the server, without having to wait for subscriptions to rerun. This is\n  // because if we disconnect and reconnect between getting the result and\n  // getting the results of subscription rerun, we WILL NOT re-send this\n  // method (because we never re-send methods whose results we've received)\n  // but we WILL call loggedInAndDataReadyCallback at \"reconnect quiesce\"\n  // time. This will lead to makeClientLoggedIn(result.id) even though we\n  // haven't actually sent a login method!\n  //\n  // But by making sure that we send this \"resume\" login in that case (and\n  // calling makeClientLoggedOut if it fails), we'll end up with an accurate\n  // client-side userId. (It's important that livedata_connection guarantees\n  // that the \"reconnect quiesce\"-time call to loggedInAndDataReadyCallback\n  // will occur before the callback from the resume login call.)\n\n  var onResultReceived = function (err, result) {\n    if (err || !result || !result.token) {// Leave onReconnect alone if there was an error, so that if the user was\n      // already logged in they will still get logged in on reconnect.\n      // See issue #4970.\n    } else {\n      self.connection.onReconnect = function () {\n        reconnected = true; // If our token was updated in storage, use the latest one.\n\n        var storedToken = self._storedLoginToken();\n\n        if (storedToken) {\n          result = {\n            token: storedToken,\n            tokenExpires: self._storedLoginTokenExpires()\n          };\n        }\n\n        if (!result.tokenExpires) result.tokenExpires = self._tokenExpiration(new Date());\n\n        if (self._tokenExpiresSoon(result.tokenExpires)) {\n          self.makeClientLoggedOut();\n        } else {\n          self.callLoginMethod({\n            methodArguments: [{\n              resume: result.token\n            }],\n            // Reconnect quiescence ensures that the user doesn't see an\n            // intermediate state before the login method finishes. So we don't\n            // need to show a logging-in animation.\n            _suppressLoggingIn: true,\n            userCallback: function (error) {\n              var storedTokenNow = self._storedLoginToken();\n\n              if (error) {\n                // If we had a login error AND the current stored token is the\n                // one that we tried to log in with, then declare ourselves\n                // logged out. If there's a token in storage but it's not the\n                // token that we tried to log in with, we don't know anything\n                // about whether that token is valid or not, so do nothing. The\n                // periodic localStorage poll will decide if we are logged in or\n                // out with this token, if it hasn't already. Of course, even\n                // with this check, another tab could insert a new valid token\n                // immediately before we clear localStorage here, which would\n                // lead to both tabs being logged out, but by checking the token\n                // in storage right now we hope to make that unlikely to happen.\n                //\n                // If there is no token in storage right now, we don't have to\n                // do anything; whatever code removed the token from storage was\n                // responsible for calling `makeClientLoggedOut()`, or the\n                // periodic localStorage poll will call `makeClientLoggedOut`\n                // eventually if another tab wiped the token from storage.\n                if (storedTokenNow && storedTokenNow === result.token) {\n                  self.makeClientLoggedOut();\n                }\n              } // Possibly a weird callback to call, but better than nothing if\n              // there is a reconnect between \"login result received\" and \"data\n              // ready\".\n\n\n              loginCallbacks(error);\n            }\n          });\n        }\n      };\n    }\n  }; // This callback is called once the local cache of the current-user\n  // subscription (and all subscriptions, in fact) are guaranteed to be up to\n  // date.\n\n\n  var loggedInAndDataReadyCallback = function (error, result) {\n    // If the login method returns its result but the connection is lost\n    // before the data is in the local cache, it'll set an onReconnect (see\n    // above). The onReconnect will try to log in using the token, and *it*\n    // will call userCallback via its own version of this\n    // loggedInAndDataReadyCallback. So we don't have to do anything here.\n    if (reconnected) return; // Note that we need to call this even if _suppressLoggingIn is true,\n    // because it could be matching a _setLoggingIn(true) from a\n    // half-completed pre-reconnect login method.\n\n    self._setLoggingIn(false);\n\n    if (error || !result) {\n      error = error || new Error(\"No result from call to \" + options.methodName);\n      loginCallbacks(error);\n      return;\n    }\n\n    try {\n      options.validateResult(result);\n    } catch (e) {\n      loginCallbacks(e);\n      return;\n    } // Make the client logged in. (The user data should already be loaded!)\n\n\n    self.makeClientLoggedIn(result.id, result.token, result.tokenExpires);\n    loginCallbacks();\n  };\n\n  if (!options._suppressLoggingIn) self._setLoggingIn(true);\n  self.connection.apply(options.methodName, options.methodArguments, {\n    wait: true,\n    onResultReceived: onResultReceived\n  }, loggedInAndDataReadyCallback);\n};\n\nAp.makeClientLoggedOut = function () {\n  // Ensure client was successfully logged in before running logout hooks.\n  if (this.connection._userId) {\n    this._onLogoutHook.each(function (callback) {\n      callback();\n      return true;\n    });\n  }\n\n  this._unstoreLoginToken();\n\n  this.connection.setUserId(null);\n  this.connection.onReconnect = null;\n};\n\nAp.makeClientLoggedIn = function (userId, token, tokenExpires) {\n  this._storeLoginToken(userId, token, tokenExpires);\n\n  this.connection.setUserId(userId);\n}; /**\n    * @summary Log the user out.\n    * @locus Client\n    * @param {Function} [callback] Optional callback. Called with no arguments on success, or with a single `Error` argument on failure.\n    * @importFromPackage meteor\n    */\n\nMeteor.logout = function (callback) {\n  return Accounts.logout(callback);\n}; /**\n    * @summary Log out other clients logged in as the current user, but does not log out the client that calls this function.\n    * @locus Client\n    * @param {Function} [callback] Optional callback. Called with no arguments on success, or with a single `Error` argument on failure.\n    * @importFromPackage meteor\n    */\n\nMeteor.logoutOtherClients = function (callback) {\n  return Accounts.logoutOtherClients(callback);\n}; ///\n/// LOGIN SERVICES\n///\n// A reactive function returning whether the loginServiceConfiguration\n// subscription is ready. Used by accounts-ui to hide the login button\n// until we have all the configuration loaded\n//\n\n\nAp.loginServicesConfigured = function () {\n  return this._loginServicesHandle.ready();\n}; // Some login services such as the redirect login flow or the resume\n// login handler can log the user in at page load time.  The\n// Meteor.loginWithX functions have a callback argument, but the\n// callback function instance won't be in memory any longer if the\n// page was reloaded.  The `onPageLoadLogin` function allows a\n// callback to be registered for the case where the login was\n// initiated in a previous VM, and we now have the result of the login\n// attempt in a new VM.\n// Register a callback to be called if we have information about a\n// login attempt at page load time.  Call the callback immediately if\n// we already have the page load login attempt info, otherwise stash\n// the callback to be called if and when we do get the attempt info.\n//\n\n\nAp.onPageLoadLogin = function (f) {\n  if (this._pageLoadLoginAttemptInfo) {\n    f(this._pageLoadLoginAttemptInfo);\n  } else {\n    this._pageLoadLoginCallbacks.push(f);\n  }\n}; // Receive the information about the login attempt at page load time.\n// Call registered callbacks, and also record the info in case\n// someone's callback hasn't been registered yet.\n//\n\n\nAp._pageLoadLogin = function (attemptInfo) {\n  if (this._pageLoadLoginAttemptInfo) {\n    Meteor._debug(\"Ignoring unexpected duplicate page load login attempt info\");\n\n    return;\n  }\n\n  _.each(this._pageLoadLoginCallbacks, function (callback) {\n    callback(attemptInfo);\n  });\n\n  this._pageLoadLoginCallbacks = [];\n  this._pageLoadLoginAttemptInfo = attemptInfo;\n}; ///\n/// HANDLEBARS HELPERS\n///\n// If our app has a Blaze, register the {{currentUser}} and {{loggingIn}}\n// global helpers.\n\n\nif (Package.blaze) {\n  /**\n   * @global\n   * @name  currentUser\n   * @isHelper true\n   * @summary Calls [Meteor.user()](#meteor_user). Use `{{#if currentUser}}` to check whether the user is logged in.\n   */Package.blaze.Blaze.Template.registerHelper('currentUser', function () {\n    return Meteor.user();\n  }); /**\n       * @global\n       * @name  loggingIn\n       * @isHelper true\n       * @summary Calls [Meteor.loggingIn()](#meteor_loggingin).\n       */\n  Package.blaze.Blaze.Template.registerHelper('loggingIn', function () {\n    return Meteor.loggingIn();\n  }); /**\n       * @global\n       * @name  loggingOut\n       * @isHelper true\n       * @summary Calls [Meteor.loggingOut()](#meteor_loggingout).\n       */\n  Package.blaze.Blaze.Template.registerHelper('loggingOut', function () {\n    return Meteor.loggingOut();\n  }); /**\n       * @global\n       * @name  loggingInOrOut\n       * @isHelper true\n       * @summary Calls [Meteor.loggingIn()](#meteor_loggingin) or [Meteor.loggingOut()](#meteor_loggingout).\n       */\n  Package.blaze.Blaze.Template.registerHelper('loggingInOrOut', function () {\n    return Meteor.loggingIn() || Meteor.loggingOut();\n  });\n}","map":{"version":3,"sources":["/packages/accounts-base/accounts_client.js"],"names":["module","export","AccountsClient","AccountsCommon","importSync","v","options","_loggingIn","ReactiveVar","_loggingOut","_loginServicesHandle","connection","subscribe","_pageLoadLoginCallbacks","_pageLoadLoginAttemptInfo","_initUrlMatching","_initLocalStorage","userId","_setLoggingIn","x","set","loggingIn","get","loggingOut","logout","callback","self","apply","wait","error","result","makeClientLoggedOut","logoutOtherClients","err","_storeLoginToken","token","tokenExpires","Ap","prototype","Meteor","Accounts","callLoginMethod","_","extend","methodName","methodArguments","_suppressLoggingIn","each","f","loginCallbacks","once","_onLoginHook","_onLoginFailureHook","userCallback","arguments","reconnected","onResultReceived","onReconnect","storedToken","_storedLoginToken","_storedLoginTokenExpires","_tokenExpiration","Date","_tokenExpiresSoon","resume","storedTokenNow","loggedInAndDataReadyCallback","Error","validateResult","e","makeClientLoggedIn","id","_userId","_onLogoutHook","_unstoreLoginToken","setUserId","loginServicesConfigured","ready","onPageLoadLogin","push","_pageLoadLogin","attemptInfo","_debug","Package","blaze","Blaze","Template","registerHelper","user"],"mappings":"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","file":"/packages/accounts-base/accounts_client.js.map","sourcesContent":["import {AccountsCommon} from \"./accounts_common.js\";\n\n/**\n * @summary Constructor for the `Accounts` object on the client.\n * @locus Client\n * @class AccountsClient\n * @extends AccountsCommon\n * @instancename accountsClient\n * @param {Object} options an object with fields:\n * @param {Object} options.connection Optional DDP connection to reuse.\n * @param {String} options.ddpUrl Optional URL for creating a new DDP connection.\n */\nexport class AccountsClient extends AccountsCommon {\n  constructor(options) {\n    super(options);\n\n    this._loggingIn = new ReactiveVar(false);\n    this._loggingOut = new ReactiveVar(false);\n\n    this._loginServicesHandle =\n      this.connection.subscribe(\"meteor.loginServiceConfiguration\");\n\n    this._pageLoadLoginCallbacks = [];\n    this._pageLoadLoginAttemptInfo = null;\n\n    // Defined in url_client.js.\n    this._initUrlMatching();\n\n    // Defined in localstorage_token.js.\n    this._initLocalStorage();\n  }\n\n  ///\n  /// CURRENT USER\n  ///\n\n  // @override\n  userId() {\n    return this.connection.userId();\n  }\n\n  // This is mostly just called within this file, but Meteor.loginWithPassword\n  // also uses it to make loggingIn() be true during the beginPasswordExchange\n  // method call too.\n  _setLoggingIn(x) {\n    this._loggingIn.set(x);\n  }\n\n  /**\n   * @summary True if a login method (such as `Meteor.loginWithPassword`, `Meteor.loginWithFacebook`, or `Accounts.createUser`) is currently in progress. A reactive data source.\n   * @locus Client\n   */\n  loggingIn() {\n    return this._loggingIn.get();\n  }\n\n  /**\n   * @summary True if a logout method (such as `Meteor.logout`) is currently in progress. A reactive data source.\n   * @locus Client\n   */\n  loggingOut() {\n    return this._loggingOut.get();\n  }\n\n  /**\n   * @summary Log the user out.\n   * @locus Client\n   * @param {Function} [callback] Optional callback. Called with no arguments on success, or with a single `Error` argument on failure.\n   */\n  logout(callback) {\n    var self = this;\n    self._loggingOut.set(true);\n    self.connection.apply('logout', [], {\n      wait: true\n    }, function (error, result) {\n      self._loggingOut.set(false);\n      if (error) {\n        callback && callback(error);\n      } else {\n        self.makeClientLoggedOut();\n        callback && callback();\n      }\n    });\n  }\n\n  /**\n   * @summary Log out other clients logged in as the current user, but does not log out the client that calls this function.\n   * @locus Client\n   * @param {Function} [callback] Optional callback. Called with no arguments on success, or with a single `Error` argument on failure.\n   */\n  logoutOtherClients(callback) {\n    var self = this;\n\n    // We need to make two method calls: one to replace our current token,\n    // and another to remove all tokens except the current one. We want to\n    // call these two methods one after the other, without any other\n    // methods running between them. For example, we don't want `logout`\n    // to be called in between our two method calls (otherwise the second\n    // method call would return an error). Another example: we don't want\n    // logout to be called before the callback for `getNewToken`;\n    // otherwise we would momentarily log the user out and then write a\n    // new token to localStorage.\n    //\n    // To accomplish this, we make both calls as wait methods, and queue\n    // them one after the other, without spinning off the event loop in\n    // between. Even though we queue `removeOtherTokens` before\n    // `getNewToken`, we won't actually send the `removeOtherTokens` call\n    // until the `getNewToken` callback has finished running, because they\n    // are both wait methods.\n    self.connection.apply(\n      'getNewToken',\n      [],\n      { wait: true },\n      function (err, result) {\n        if (! err) {\n          self._storeLoginToken(\n            self.userId(),\n            result.token,\n            result.tokenExpires\n          );\n        }\n      }\n    );\n\n    self.connection.apply(\n      'removeOtherTokens',\n      [],\n      { wait: true },\n      function (err) {\n        callback && callback(err);\n      }\n    );\n  }\n};\n\nvar Ap = AccountsClient.prototype;\n\n/**\n * @summary True if a login method (such as `Meteor.loginWithPassword`, `Meteor.loginWithFacebook`, or `Accounts.createUser`) is currently in progress. A reactive data source.\n * @locus Client\n * @importFromPackage meteor\n */\nMeteor.loggingIn = function () {\n  return Accounts.loggingIn();\n};\n\n/**\n * @summary True if a logout method (such as `Meteor.logout`) is currently in progress. A reactive data source.\n * @locus Client\n * @importFromPackage meteor\n */\nMeteor.loggingOut = function () {\n  return Accounts.loggingOut();\n};\n\n///\n/// LOGIN METHODS\n///\n\n// Call a login method on the server.\n//\n// A login method is a method which on success calls `this.setUserId(id)` and\n// `Accounts._setLoginToken` on the server and returns an object with fields\n// 'id' (containing the user id), 'token' (containing a resume token), and\n// optionally `tokenExpires`.\n//\n// This function takes care of:\n//   - Updating the Meteor.loggingIn() reactive data source\n//   - Calling the method in 'wait' mode\n//   - On success, saving the resume token to localStorage\n//   - On success, calling Accounts.connection.setUserId()\n//   - Setting up an onReconnect handler which logs in with\n//     the resume token\n//\n// Options:\n// - methodName: The method to call (default 'login')\n// - methodArguments: The arguments for the method\n// - validateResult: If provided, will be called with the result of the\n//                 method. If it throws, the client will not be logged in (and\n//                 its error will be passed to the callback).\n// - userCallback: Will be called with no arguments once the user is fully\n//                 logged in, or with the error on error.\n//\nAp.callLoginMethod = function (options) {\n  var self = this;\n\n  options = _.extend({\n    methodName: 'login',\n    methodArguments: [{}],\n    _suppressLoggingIn: false\n  }, options);\n\n  // Set defaults for callback arguments to no-op functions; make sure we\n  // override falsey values too.\n  _.each(['validateResult', 'userCallback'], function (f) {\n    if (!options[f])\n      options[f] = function () {};\n  });\n\n  // Prepare callbacks: user provided and onLogin/onLoginFailure hooks.\n  var loginCallbacks = _.once(function (error) {\n    if (!error) {\n      self._onLoginHook.each(function (callback) {\n        callback();\n        return true;\n      });\n    } else {\n      self._onLoginFailureHook.each(function (callback) {\n        callback({ error });\n        return true;\n      });\n    }\n    options.userCallback.apply(this, arguments);\n  });\n\n  var reconnected = false;\n\n  // We want to set up onReconnect as soon as we get a result token back from\n  // the server, without having to wait for subscriptions to rerun. This is\n  // because if we disconnect and reconnect between getting the result and\n  // getting the results of subscription rerun, we WILL NOT re-send this\n  // method (because we never re-send methods whose results we've received)\n  // but we WILL call loggedInAndDataReadyCallback at \"reconnect quiesce\"\n  // time. This will lead to makeClientLoggedIn(result.id) even though we\n  // haven't actually sent a login method!\n  //\n  // But by making sure that we send this \"resume\" login in that case (and\n  // calling makeClientLoggedOut if it fails), we'll end up with an accurate\n  // client-side userId. (It's important that livedata_connection guarantees\n  // that the \"reconnect quiesce\"-time call to loggedInAndDataReadyCallback\n  // will occur before the callback from the resume login call.)\n  var onResultReceived = function (err, result) {\n    if (err || !result || !result.token) {\n      // Leave onReconnect alone if there was an error, so that if the user was\n      // already logged in they will still get logged in on reconnect.\n      // See issue #4970.\n    } else {\n      self.connection.onReconnect = function () {\n        reconnected = true;\n        // If our token was updated in storage, use the latest one.\n        var storedToken = self._storedLoginToken();\n        if (storedToken) {\n          result = {\n            token: storedToken,\n            tokenExpires: self._storedLoginTokenExpires()\n          };\n        }\n        if (! result.tokenExpires)\n          result.tokenExpires = self._tokenExpiration(new Date());\n        if (self._tokenExpiresSoon(result.tokenExpires)) {\n          self.makeClientLoggedOut();\n        } else {\n          self.callLoginMethod({\n            methodArguments: [{resume: result.token}],\n            // Reconnect quiescence ensures that the user doesn't see an\n            // intermediate state before the login method finishes. So we don't\n            // need to show a logging-in animation.\n            _suppressLoggingIn: true,\n            userCallback: function (error) {\n              var storedTokenNow = self._storedLoginToken();\n              if (error) {\n                // If we had a login error AND the current stored token is the\n                // one that we tried to log in with, then declare ourselves\n                // logged out. If there's a token in storage but it's not the\n                // token that we tried to log in with, we don't know anything\n                // about whether that token is valid or not, so do nothing. The\n                // periodic localStorage poll will decide if we are logged in or\n                // out with this token, if it hasn't already. Of course, even\n                // with this check, another tab could insert a new valid token\n                // immediately before we clear localStorage here, which would\n                // lead to both tabs being logged out, but by checking the token\n                // in storage right now we hope to make that unlikely to happen.\n                //\n                // If there is no token in storage right now, we don't have to\n                // do anything; whatever code removed the token from storage was\n                // responsible for calling `makeClientLoggedOut()`, or the\n                // periodic localStorage poll will call `makeClientLoggedOut`\n                // eventually if another tab wiped the token from storage.\n                if (storedTokenNow && storedTokenNow === result.token) {\n                  self.makeClientLoggedOut();\n                }\n              }\n              // Possibly a weird callback to call, but better than nothing if\n              // there is a reconnect between \"login result received\" and \"data\n              // ready\".\n              loginCallbacks(error);\n            }});\n        }\n      };\n    }\n  };\n\n  // This callback is called once the local cache of the current-user\n  // subscription (and all subscriptions, in fact) are guaranteed to be up to\n  // date.\n  var loggedInAndDataReadyCallback = function (error, result) {\n    // If the login method returns its result but the connection is lost\n    // before the data is in the local cache, it'll set an onReconnect (see\n    // above). The onReconnect will try to log in using the token, and *it*\n    // will call userCallback via its own version of this\n    // loggedInAndDataReadyCallback. So we don't have to do anything here.\n    if (reconnected)\n      return;\n\n    // Note that we need to call this even if _suppressLoggingIn is true,\n    // because it could be matching a _setLoggingIn(true) from a\n    // half-completed pre-reconnect login method.\n    self._setLoggingIn(false);\n    if (error || !result) {\n      error = error || new Error(\n        \"No result from call to \" + options.methodName);\n      loginCallbacks(error);\n      return;\n    }\n    try {\n      options.validateResult(result);\n    } catch (e) {\n      loginCallbacks(e);\n      return;\n    }\n\n    // Make the client logged in. (The user data should already be loaded!)\n    self.makeClientLoggedIn(result.id, result.token, result.tokenExpires);\n    loginCallbacks();\n  };\n\n  if (!options._suppressLoggingIn)\n    self._setLoggingIn(true);\n  self.connection.apply(\n    options.methodName,\n    options.methodArguments,\n    {wait: true, onResultReceived: onResultReceived},\n    loggedInAndDataReadyCallback);\n};\n\nAp.makeClientLoggedOut = function () {\n  // Ensure client was successfully logged in before running logout hooks.\n  if (this.connection._userId) {\n    this._onLogoutHook.each(function (callback) {\n      callback();\n      return true;\n    });\n  }\n  this._unstoreLoginToken();\n  this.connection.setUserId(null);\n  this.connection.onReconnect = null;\n};\n\nAp.makeClientLoggedIn = function (userId, token, tokenExpires) {\n  this._storeLoginToken(userId, token, tokenExpires);\n  this.connection.setUserId(userId);\n};\n\n/**\n * @summary Log the user out.\n * @locus Client\n * @param {Function} [callback] Optional callback. Called with no arguments on success, or with a single `Error` argument on failure.\n * @importFromPackage meteor\n */\nMeteor.logout = function (callback) {\n  return Accounts.logout(callback);\n};\n\n/**\n * @summary Log out other clients logged in as the current user, but does not log out the client that calls this function.\n * @locus Client\n * @param {Function} [callback] Optional callback. Called with no arguments on success, or with a single `Error` argument on failure.\n * @importFromPackage meteor\n */\nMeteor.logoutOtherClients = function (callback) {\n  return Accounts.logoutOtherClients(callback);\n};\n\n\n///\n/// LOGIN SERVICES\n///\n\n// A reactive function returning whether the loginServiceConfiguration\n// subscription is ready. Used by accounts-ui to hide the login button\n// until we have all the configuration loaded\n//\nAp.loginServicesConfigured = function () {\n  return this._loginServicesHandle.ready();\n};\n\n\n// Some login services such as the redirect login flow or the resume\n// login handler can log the user in at page load time.  The\n// Meteor.loginWithX functions have a callback argument, but the\n// callback function instance won't be in memory any longer if the\n// page was reloaded.  The `onPageLoadLogin` function allows a\n// callback to be registered for the case where the login was\n// initiated in a previous VM, and we now have the result of the login\n// attempt in a new VM.\n\n// Register a callback to be called if we have information about a\n// login attempt at page load time.  Call the callback immediately if\n// we already have the page load login attempt info, otherwise stash\n// the callback to be called if and when we do get the attempt info.\n//\nAp.onPageLoadLogin = function (f) {\n  if (this._pageLoadLoginAttemptInfo) {\n    f(this._pageLoadLoginAttemptInfo);\n  } else {\n    this._pageLoadLoginCallbacks.push(f);\n  }\n};\n\n\n// Receive the information about the login attempt at page load time.\n// Call registered callbacks, and also record the info in case\n// someone's callback hasn't been registered yet.\n//\nAp._pageLoadLogin = function (attemptInfo) {\n  if (this._pageLoadLoginAttemptInfo) {\n    Meteor._debug(\"Ignoring unexpected duplicate page load login attempt info\");\n    return;\n  }\n\n  _.each(this._pageLoadLoginCallbacks, function (callback) {\n    callback(attemptInfo);\n  });\n\n  this._pageLoadLoginCallbacks = [];\n  this._pageLoadLoginAttemptInfo = attemptInfo;\n};\n\n\n///\n/// HANDLEBARS HELPERS\n///\n\n// If our app has a Blaze, register the {{currentUser}} and {{loggingIn}}\n// global helpers.\nif (Package.blaze) {\n  /**\n   * @global\n   * @name  currentUser\n   * @isHelper true\n   * @summary Calls [Meteor.user()](#meteor_user). Use `{{#if currentUser}}` to check whether the user is logged in.\n   */\n  Package.blaze.Blaze.Template.registerHelper('currentUser', function () {\n    return Meteor.user();\n  });\n\n  /**\n   * @global\n   * @name  loggingIn\n   * @isHelper true\n   * @summary Calls [Meteor.loggingIn()](#meteor_loggingin).\n   */\n  Package.blaze.Blaze.Template.registerHelper('loggingIn', function () {\n    return Meteor.loggingIn();\n  });\n\n  /**\n   * @global\n   * @name  loggingOut\n   * @isHelper true\n   * @summary Calls [Meteor.loggingOut()](#meteor_loggingout).\n   */\n  Package.blaze.Blaze.Template.registerHelper('loggingOut', function () {\n    return Meteor.loggingOut();\n  });\n\n  /**\n   * @global\n   * @name  loggingInOrOut\n   * @isHelper true\n   * @summary Calls [Meteor.loggingIn()](#meteor_loggingin) or [Meteor.loggingOut()](#meteor_loggingout).\n   */\n  Package.blaze.Blaze.Template.registerHelper('loggingInOrOut', function () {\n    return (Meteor.loggingIn() || Meteor.loggingOut());\n  });\n}\n"]},"hash":"82f7a9fff062ff522e298d19e3961299f14be4b5"}
