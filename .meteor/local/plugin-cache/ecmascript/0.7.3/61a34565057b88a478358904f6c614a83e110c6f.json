{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[{"source":"meteor/meteor","imported":["Meteor"],"specifiers":[{"kind":"named","imported":"Meteor","local":"Meteor"}]},{"source":"meteor/underscore","imported":["_"],"specifiers":[{"kind":"named","imported":"_","local":"_"}]},{"source":"moment","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"moment"}]},{"source":"meteor/percolate:synced-cron","imported":["SyncedCron"],"specifiers":[{"kind":"named","imported":"SyncedCron","local":"SyncedCron"}]},{"source":"/imports/api/server/utils","imported":["sendEmail"],"specifiers":[{"kind":"named","imported":"sendEmail","local":"sendEmail"}]},{"source":"/imports/api/customers/customers","imported":["Customers"],"specifiers":[{"kind":"named","imported":"Customers","local":"Customers"}]},{"source":"/imports/api/brands/brands","imported":["Brands"],"specifiers":[{"kind":"named","imported":"Brands","local":"Brands"}]},{"source":"../conversations","imported":["Conversations"],"specifiers":[{"kind":"named","imported":"Conversations","local":"Conversations"}]},{"source":"../constants","imported":["CONVERSATION_STATUSES"],"specifiers":[{"kind":"named","imported":"CONVERSATION_STATUSES","local":"CONVERSATION_STATUSES"}]},{"source":"../messages","imported":["Messages"],"specifiers":[{"kind":"named","imported":"Messages","local":"Messages"}]}],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/imports/api/conversations/server/cronJobs.js","filenameRelative":"/imports/api/conversations/server/cronJobs.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/imports/api/conversations/server/cronJobs.js.map","sourceFileName":"/imports/api/conversations/server/cronJobs.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"cronJobs"},"ignored":false,"code":"var Meteor = void 0;\nmodule.importSync(\"meteor/meteor\", {\n  Meteor: function (v) {\n    Meteor = v;\n  }\n}, 0);\n\nvar _ = void 0;\n\nmodule.importSync(\"meteor/underscore\", {\n  _: function (v) {\n    _ = v;\n  }\n}, 1);\nvar moment = void 0;\nmodule.importSync(\"moment\", {\n  \"default\": function (v) {\n    moment = v;\n  }\n}, 2);\nvar SyncedCron = void 0;\nmodule.importSync(\"meteor/percolate:synced-cron\", {\n  SyncedCron: function (v) {\n    SyncedCron = v;\n  }\n}, 3);\nvar sendEmail = void 0;\nmodule.importSync(\"/imports/api/server/utils\", {\n  sendEmail: function (v) {\n    sendEmail = v;\n  }\n}, 4);\nvar Customers = void 0;\nmodule.importSync(\"/imports/api/customers/customers\", {\n  Customers: function (v) {\n    Customers = v;\n  }\n}, 5);\nvar Brands = void 0;\nmodule.importSync(\"/imports/api/brands/brands\", {\n  Brands: function (v) {\n    Brands = v;\n  }\n}, 6);\nvar Conversations = void 0;\nmodule.importSync(\"../conversations\", {\n  Conversations: function (v) {\n    Conversations = v;\n  }\n}, 7);\nvar CONVERSATION_STATUSES = void 0;\nmodule.importSync(\"../constants\", {\n  CONVERSATION_STATUSES: function (v) {\n    CONVERSATION_STATUSES = v;\n  }\n}, 8);\nvar Messages = void 0;\nmodule.importSync(\"../messages\", {\n  Messages: function (v) {\n    Messages = v;\n  }\n}, 9);\n\nfunction sendMessageEmail() {\n  // new or open conversations\n  var conversations = Conversations.find({\n    status: {\n      $in: [CONVERSATION_STATUSES.NEW, CONVERSATION_STATUSES.OPEN]\n    }\n  }, {\n    fields: {\n      _id: 1,\n      customerId: 1,\n      brandId: 1\n    }\n  });\n\n  _.each(conversations.fetch(), function (conversation) {\n    var customer = Customers.findOne(conversation.customerId);\n    var brand = Brands.findOne(conversation.brandId);\n\n    if (!customer || !customer.email) {\n      return;\n    }\n\n    if (!brand) {\n      return;\n    } // user's last non answered question\n\n\n    var question = Messages.findOne({\n      conversationId: conversation._id,\n      customerId: {\n        $exists: true\n      }\n    }, {\n      sort: {\n        createdAt: -1\n      }\n    }) || {};\n    question.createdAt = moment(question.createdAt).format('DD MMM YY, HH:mm'); // generate admin unread answers\n\n    var answers = [];\n    var adminMessages = Messages.find({\n      conversationId: conversation._id,\n      userId: {\n        $exists: true\n      },\n      isCustomerRead: {\n        $exists: false\n      },\n      // exclude internal notes\n      internal: false\n    }, {\n      sort: {\n        createdAt: 1\n      }\n    }).fetch();\n\n    _.each(adminMessages, function (message) {\n      var answer = message; // add user object to answer\n\n      answer.user = Meteor.users.findOne(message.userId);\n      answer.createdAt = moment(answer.createdAt).format('DD MMM YY, HH:mm');\n      answers.push(answer);\n    });\n\n    if (answers.length < 1) {\n      return;\n    } // template data\n\n\n    var data = {\n      customer: customer,\n      question: question,\n      answers: answers,\n      brand: brand\n    }; // add user's signature\n\n    var user = Meteor.users.findOne(answers[0].userId);\n\n    if (user && user.emailSignatures) {\n      var signature = _.find(user.emailSignatures, function (s) {\n        return brand._id === s.brandId;\n      });\n\n      if (signature) {\n        data.signature = signature.signature;\n      }\n    } // send email\n\n\n    sendEmail({\n      to: customer.email,\n      subject: \"Reply from \\\"\" + brand.name + \"\\\"\",\n      template: {\n        name: 'conversationCron',\n        isCustom: true,\n        data: data\n      }\n    }); // mark sent messages as read\n\n    Messages.update({\n      conversationId: conversation._id,\n      userId: {\n        $exists: true\n      },\n      isCustomerRead: {\n        $exists: false\n      }\n    }, {\n      $set: {\n        isCustomerRead: true\n      }\n    }, {\n      multi: true\n    });\n  });\n}\n\nSyncedCron.add({\n  name: \"Send unread conversation messages to customer's email\",\n  schedule: function (parser) {\n    // return parser.text('every 10 seconds');\n    return parser.text('every 10 minutes');\n  },\n  job: function () {\n    sendMessageEmail();\n  }\n});","map":{"version":3,"sources":["/imports/api/conversations/server/cronJobs.js"],"names":["Meteor","module","importSync","v","_","moment","SyncedCron","sendEmail","Customers","Brands","Conversations","CONVERSATION_STATUSES","Messages","sendMessageEmail","conversations","find","status","$in","NEW","OPEN","fields","_id","customerId","brandId","each","fetch","customer","findOne","conversation","brand","email","question","conversationId","$exists","sort","createdAt","format","answers","adminMessages","userId","isCustomerRead","internal","answer","message","user","users","push","length","data","emailSignatures","signature","s","to","subject","name","template","isCustom","update","$set","multi","add","schedule","parser","text","job"],"mappings":"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","file":"/imports/api/conversations/server/cronJobs.js.map","sourcesContent":["import { Meteor } from 'meteor/meteor';\nimport { _ } from 'meteor/underscore';\nimport moment from 'moment';\nimport { SyncedCron } from 'meteor/percolate:synced-cron';\nimport { sendEmail } from '/imports/api/server/utils';\nimport { Customers } from '/imports/api/customers/customers';\nimport { Brands } from '/imports/api/brands/brands';\nimport { Conversations } from '../conversations';\nimport { CONVERSATION_STATUSES } from '../constants';\nimport { Messages } from '../messages';\n\nfunction sendMessageEmail() {\n  // new or open conversations\n  const conversations = Conversations.find(\n    {\n      status: { $in: [CONVERSATION_STATUSES.NEW, CONVERSATION_STATUSES.OPEN] },\n    },\n    { fields: { _id: 1, customerId: 1, brandId: 1 } },\n  );\n\n  _.each(conversations.fetch(), conversation => {\n    const customer = Customers.findOne(conversation.customerId);\n    const brand = Brands.findOne(conversation.brandId);\n\n    if (!customer || !customer.email) {\n      return;\n    }\n    if (!brand) {\n      return;\n    }\n\n    // user's last non answered question\n    const question = Messages.findOne(\n      {\n        conversationId: conversation._id,\n        customerId: { $exists: true },\n      },\n      { sort: { createdAt: -1 } },\n    ) || {};\n\n    question.createdAt = moment(question.createdAt).format('DD MMM YY, HH:mm');\n\n    // generate admin unread answers\n    const answers = [];\n\n    const adminMessages = Messages.find(\n      {\n        conversationId: conversation._id,\n        userId: { $exists: true },\n        isCustomerRead: { $exists: false },\n\n        // exclude internal notes\n        internal: false,\n      },\n      { sort: { createdAt: 1 } },\n    ).fetch();\n\n    _.each(adminMessages, message => {\n      const answer = message;\n\n      // add user object to answer\n      answer.user = Meteor.users.findOne(message.userId);\n      answer.createdAt = moment(answer.createdAt).format('DD MMM YY, HH:mm');\n      answers.push(answer);\n    });\n\n    if (answers.length < 1) {\n      return;\n    }\n\n    // template data\n    const data = { customer, question, answers, brand };\n\n    // add user's signature\n    const user = Meteor.users.findOne(answers[0].userId);\n\n    if (user && user.emailSignatures) {\n      const signature = _.find(user.emailSignatures, s => brand._id === s.brandId);\n\n      if (signature) {\n        data.signature = signature.signature;\n      }\n    }\n\n    // send email\n    sendEmail({\n      to: customer.email,\n      subject: `Reply from \"${brand.name}\"`,\n      template: {\n        name: 'conversationCron',\n        isCustom: true,\n        data,\n      },\n    });\n\n    // mark sent messages as read\n    Messages.update(\n      {\n        conversationId: conversation._id,\n        userId: { $exists: true },\n        isCustomerRead: { $exists: false },\n      },\n      { $set: { isCustomerRead: true } },\n      { multi: true },\n    );\n  });\n}\n\nSyncedCron.add({\n  name: \"Send unread conversation messages to customer's email\",\n\n  schedule(parser) {\n    // return parser.text('every 10 seconds');\n    return parser.text('every 10 minutes');\n  },\n\n  job() {\n    sendMessageEmail();\n  },\n});\n"]},"hash":"61a34565057b88a478358904f6c614a83e110c6f"}
